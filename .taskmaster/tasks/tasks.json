{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Utworzenie i konfiguracja GitHub repository",
        "description": "Stworzenie głównego repozytorium GitHub, konfiguracja struktury branchy i podstawowych plików",
        "details": "Użyj `gh repo create multimedia-portal --public --clone` lub stwórz przez GitHub Web UI. Skonfiguruj branche main i develop, dodaj .gitignore dla Node.js, utwórz templates dla Issues i Pull Requestów, skonfiguruj branch protection rules. Pierwszy commit powinien zawierać .gitignore, README.md i podstawową strukturę.",
        "testStrategy": "Sprawdź czy repository jest dostępne na GitHub, branche istnieją, .gitignore zawiera odpowiednie wpisy dla Node.js, templates są dostępne w .github/",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie repozytorium GitHub za pomocą gh CLI lub Web UI",
            "description": "Stworzenie nowego publicznego repozytorium GitHub o nazwie multimedia-portal z podstawową konfiguracją",
            "dependencies": [],
            "details": "Użyj polecenia `gh repo create multimedia-portal --public --clone` lub stwórz repozytorium przez interfejs GitHub Web UI. Upewnij się, że repozytorium jest publiczne i zostało sklonowane lokalnie. Skonfiguruj podstawowe ustawienia repozytorium.",
            "status": "done",
            "testStrategy": "Sprawdź czy repozytorium jest dostępne pod adresem github.com/[username]/multimedia-portal i czy zostało prawidłowo sklonowane lokalnie",
            "updatedAt": "2025-11-06T02:15:18.413Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Konfiguracja struktury branchy main i develop",
            "description": "Utworzenie i konfiguracja podstawowych branchy oraz ustawienie branch protection rules",
            "dependencies": [
              1
            ],
            "details": "Stwórz branch develop z main: `git checkout -b develop`. Skonfiguruj branch protection rules dla main: wymagaj pull requestów, wymagaj review, wymagaj statusu checks. Ustaw develop jako domyślny branch dla developmentu.",
            "status": "done",
            "testStrategy": "Sprawdź czy oba branche (main, develop) istnieją na GitHub, branch protection rules są aktywne dla main",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:15:24.664Z"
          },
          {
            "id": 3,
            "title": "Dodanie pliku .gitignore dla Node.js",
            "description": "Utworzenie kompleksowego pliku .gitignore dostosowanego do projektów Node.js i multimedia",
            "dependencies": [
              1
            ],
            "details": "Stwórz .gitignore zawierający standardowe wpisy Node.js: node_modules/, .env*, dist/, build/, .next/, coverage/, .nyc_output/, logs/, *.log. Dodaj wpisy specyficzne dla multimedia: uploads/, temp/, .DS_Store, Thumbs.db.",
            "status": "done",
            "testStrategy": "Sprawdź czy .gitignore zawiera wszystkie wymagane wpisy dla Node.js i nie commituje niepotrzebnych plików",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:15:28.048Z"
          },
          {
            "id": 4,
            "title": "Utworzenie templates dla Issues i Pull Requestów",
            "description": "Stworzenie standardowych szablonów GitHub dla Issues i Pull Requestów w folderze .github",
            "dependencies": [
              1
            ],
            "details": "Stwórz folder .github/ z podfolderami ISSUE_TEMPLATE/ i PULL_REQUEST_TEMPLATE/. Utwórz szablony: bug-report.md, feature-request.md, pull-request-template.md z odpowiednimi sekcjami i checklistami.",
            "status": "done",
            "testStrategy": "Sprawdź czy templates są dostępne w interfejsie GitHub przy tworzeniu nowych Issues i Pull Requestów",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:15:31.484Z"
          },
          {
            "id": 5,
            "title": "Pierwszy commit z podstawowymi plikami projektu",
            "description": "Wykonanie pierwszego commitu zawierającego .gitignore, README.md i podstawową strukturę folderów",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Stwórz README.md z opisem projektu, instrukcjami instalacji i developmentu. Dodaj podstawową strukturę folderów: backend/, frontend/, docs/. Wykonaj commit: 'Initial commit: project structure and configuration'.",
            "status": "done",
            "testStrategy": "Sprawdź czy pierwszy commit zawiera wszystkie podstawowe pliki, README.md jest czytelny i zawiera wymagane informacje",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:15:34.927Z"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już odpowiednio rozłożone na 5 subtasków obejmujących wszystkie aspekty tworzenia repozytorium GitHub.",
        "updatedAt": "2025-11-06T02:15:34.927Z"
      },
      {
        "id": "2",
        "title": "Utworzenie struktury projektu i Docker Compose",
        "description": "Skonfigurowanie podstawowej struktury folderów i pliku docker-compose.yml z wszystkimi wymaganymi serwisami",
        "details": "Stwórz foldery: backend/, frontend/, .docker/. Skonfiguruj docker-compose.yml z serwisami: postgres, redis, meilisearch, minio, backend (NestJS), frontend (Next.js). Dodaj odpowiednie wolumeny, sieci i zmienne środowiskowe. Utwórz pliki .env.example.",
        "testStrategy": "Sprawdź czy `docker-compose up -d` uruchamia wszystkie kontenery, każdy serwis jest dostępny na swoim porcie, health checki przechodzą",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie podstawowej struktury folderów projektu",
            "description": "Stworzenie głównych folderów backend/, frontend/ i .docker/ wraz z podstawową organizacją plików",
            "dependencies": [],
            "details": "Utwórz foldery: backend/ (dla aplikacji NestJS), frontend/ (dla aplikacji Next.js), .docker/ (dla plików konfiguracyjnych Docker). W każdym folderze dodaj plik .gitkeep aby zachować strukturę w Git. Upewnij się że struktura jest zgodna z konwencjami projektów fullstack.",
            "status": "done",
            "testStrategy": "Sprawdź czy wszystkie foldery istnieją: backend/, frontend/, .docker/, każdy folder zawiera .gitkeep",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:17:31.810Z"
          },
          {
            "id": 2,
            "title": "Konfiguracja docker-compose.yml z serwisami bazy danych",
            "description": "Skonfigurowanie PostgreSQL, Redis, MeiliSearch i MinIO w docker-compose.yml",
            "dependencies": [
              1
            ],
            "details": "Utwórz docker-compose.yml z serwisami: postgres:15 (port 5432, baza multimedia_portal), redis:7-alpine (port 6379), meilisearch/meilisearch:latest (port 7700), minio/minio:latest (porty 9000, 9001). Skonfiguruj wolumeny dla trwałych danych, sieci backend-network. Dodaj health checki dla wszystkich serwisów.",
            "status": "done",
            "testStrategy": "Sprawdź czy `docker-compose up -d postgres redis meilisearch minio` uruchamia wszystkie serwisy, porty są dostępne",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:18:12.904Z"
          },
          {
            "id": 3,
            "title": "Dodanie serwisów backend i frontend do docker-compose.yml",
            "description": "Konfiguracja kontenerów dla aplikacji NestJS backend i Next.js frontend",
            "dependencies": [
              2
            ],
            "details": "Dodaj do docker-compose.yml serwisy: backend (budowany z ./backend/Dockerfile, port 3001, volumes dla hot reload), frontend (budowany z ./frontend/Dockerfile, port 3000, volumes dla hot reload). Skonfiguruj depends_on dla backend (postgres, redis). Dodaj restart policies.",
            "status": "done",
            "testStrategy": "Sprawdź czy kompletny docker-compose.yml zawiera wszystkie 6 serwisów z odpowiednimi portami i zależnościami",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:18:20.626Z"
          },
          {
            "id": 4,
            "title": "Konfiguracja zmiennych środowiskowych",
            "description": "Utworzenie plików .env.example dla backend, frontend i docker-compose",
            "dependencies": [
              3
            ],
            "details": "Utwórz .env.example w root z zmiennymi dla Docker (POSTGRES_PASSWORD, REDIS_URL, MINIO_ACCESS_KEY). Utwórz backend/.env.example (DATABASE_URL, JWT_SECRET, REDIS_URL). Utwórz frontend/.env.example (NEXT_PUBLIC_API_URL). Dodaj dokumentację dla każdej zmiennej.",
            "status": "done",
            "testStrategy": "Sprawdź czy wszystkie pliki .env.example istnieją i zawierają wymagane zmienne z przykładowymi wartościami",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:18:55.035Z"
          },
          {
            "id": 5,
            "title": "Weryfikacja i testowanie pełnej konfiguracji Docker",
            "description": "Przetestowanie kompletnej konfiguracji docker-compose i naprawienie problemów",
            "dependencies": [
              4
            ],
            "details": "Wykonaj `docker-compose up -d` i sprawdź czy wszystkie kontenery startują poprawnie. Przetestuj połączenia między serwisami. Sprawdź logi każdego serwisu. Utwórz skrypt setup.sh dla szybkiego uruchamiania środowiska. Dodaj instrukcje w README.md.",
            "status": "done",
            "testStrategy": "Sprawdź czy `docker-compose up -d` uruchamia wszystkie 6 serwisów bez błędów, health checki przechodzą, wszystkie porty odpowiadają",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:19:40.866Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już właściwy podział na 5 subtasków pokrywających strukturę folderów, konfigurację Docker Compose i zmienne środowiskowe.",
        "updatedAt": "2025-11-06T02:19:40.866Z"
      },
      {
        "id": "3",
        "title": "Inicjalizacja projektu NestJS backend",
        "description": "Stworzenie aplikacji NestJS z podstawowymi modułami i konfiguracją",
        "details": "Użyj `nest new backend` w folderze backend/. Zainstaluj wymagane dependencje: @nestjs/config, @nestjs/jwt, @nestjs/passport, @nestjs/swagger, @prisma/client, prisma, bcrypt, class-validator, class-transformer. Skonfiguruj podstawową strukturę modułów: app, auth, config. Dodaj Dockerfile dla backend.",
        "testStrategy": "Sprawdź czy `npm run start:dev` w folderze backend uruchamia serwer na porcie 3001, endpoint /api/health zwraca 200 OK",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie nowego projektu NestJS",
            "description": "Inicjalizacja nowej aplikacji NestJS w folderze backend za pomocą CLI",
            "dependencies": [],
            "details": "Użyj komendy `nest new backend` w głównym folderze projektu. Upewnij się, że CLI NestJS jest zainstalowany (`npm i -g @nestjs/cli`). Wybierz npm jako package manager podczas instalacji. Sprawdź czy struktura folderów została utworzona poprawnie.",
            "status": "done",
            "testStrategy": "Sprawdź czy folder backend zawiera standardową strukturę NestJS (src/, test/, package.json), uruchom `npm run start:dev` i zweryfikuj czy serwer startuje bez błędów",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:25:42.782Z"
          },
          {
            "id": 2,
            "title": "Instalacja wymaganych dependencies",
            "description": "Instalacja wszystkich niezbędnych pakietów dla funkcjonalności backend'u",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj dependencies: `npm install @nestjs/config @nestjs/jwt @nestjs/passport @nestjs/swagger @prisma/client prisma bcrypt class-validator class-transformer`. Zainstaluj dev dependencies: `npm install -D @types/bcrypt`. Sprawdź czy wszystkie pakiety zostały dodane do package.json.",
            "status": "done",
            "testStrategy": "Zweryfikuj czy wszystkie dependencies są w package.json, uruchom `npm install` i sprawdź czy nie ma błędów podczas instalacji, sprawdź czy można importować główne klasy z każdego pakietu",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:26:47.104Z"
          },
          {
            "id": 3,
            "title": "Konfiguracja podstawowych modułów aplikacji",
            "description": "Stworzenie i konfiguracja modułów app, auth i config dla podstawowej architektury",
            "dependencies": [
              2
            ],
            "details": "Wygeneruj moduły: `nest generate module config`, `nest generate module auth`. Skonfiguruj ConfigModule w app.module.ts z isGlobal: true. Stwórz podstawową strukturę folderów: src/config/, src/auth/, src/common/. Dodaj podstawowy environment validation schema.",
            "status": "done",
            "testStrategy": "Sprawdź czy moduły są poprawnie zaimportowane w app.module.ts, zweryfikuj czy ConfigModule ładuje zmienne środowiskowe, sprawdź czy struktura folderów odpowiada konwencjom NestJS",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:35:02.698Z"
          },
          {
            "id": 4,
            "title": "Konfiguracja podstawowych middleware i guards",
            "description": "Setup podstawowych komponentów bezpieczeństwa i middleware dla aplikacji",
            "dependencies": [
              3
            ],
            "details": "Skonfiguruj CORS middleware, helmet dla bezpieczeństwa, podstawowy JWT strategy w auth module. Stwórz JwtAuthGuard i RolesGuard. Dodaj ValidationPipe globalnie. Skonfiguruj Swagger documentation z @nestjs/swagger.",
            "status": "done",
            "testStrategy": "Sprawdź czy CORS działa dla frontend'u, zweryfikuj czy Swagger jest dostępny pod /api, sprawdź czy ValidationPipe odrzuca nieprawidłowe dane, test podstawowej autentykacji JWT",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:35:06.335Z"
          },
          {
            "id": 5,
            "title": "Dodanie Dockerfile i health check endpoint",
            "description": "Utworzenie Dockerfile dla konteneryzacji i endpoint zdrowia aplikacji",
            "dependencies": [
              4
            ],
            "details": "Stwórz Dockerfile z Node.js 18+ base image, multi-stage build dla optymalizacji. Dodaj health check endpoint /api/health w app.controller.ts zwracający status 200 i podstawowe informacje o aplikacji. Skonfiguruj .dockerignore file.",
            "status": "done",
            "testStrategy": "Zbuduj Docker image (`docker build -t backend .`), uruchom kontener i sprawdź czy endpoint /api/health odpowiada statusem 200, zweryfikuj czy `npm run start:dev` uruchamia serwer na porcie 3001",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:35:10.077Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już właściwie podzielone na 5 subtasków obejmujących setup NestJS, instalację dependencies i podstawową konfigurację.",
        "updatedAt": "2025-11-06T02:35:10.077Z"
      },
      {
        "id": "4",
        "title": "Inicjalizacja projektu Next.js frontend",
        "description": "Stworzenie aplikacji Next.js 14 z App Router i podstawowymi dependencjami",
        "details": "Użyj `npx create-next-app@latest frontend --typescript --tailwind --app --src-dir --import-alias '@/*'`. Zainstaluj dependencje: @tanstack/react-query, zustand, socket.io-client, react-hook-form, zod, framer-motion, lucide-react. Skonfiguruj podstawową strukturę folderów w src/. Dodaj Dockerfile dla frontend.",
        "testStrategy": "Sprawdź czy `npm run dev` w folderze frontend uruchamia aplikację na porcie 3000, strona główna ładuje się poprawnie",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie aplikacji Next.js 14 z podstawową konfiguracją",
            "description": "Inicjalizacja nowego projektu Next.js 14 z TypeScript, Tailwind CSS, App Router i src directory",
            "dependencies": [],
            "details": "Uruchom `npx create-next-app@latest frontend --typescript --tailwind --app --src-dir --import-alias '@/*'` w głównym folderze projektu. Sprawdź czy wszystkie opcje zostały poprawnie skonfigurowane: TypeScript, Tailwind CSS, App Router, src/ directory i import alias @/*",
            "status": "done",
            "testStrategy": "Sprawdź czy folder frontend został utworzony, package.json zawiera odpowiednie zależności i skrypty, tsconfig.json jest skonfigurowany z import alias",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:37:35.358Z"
          },
          {
            "id": 2,
            "title": "Instalacja bibliotek do zarządzania stanem i UI",
            "description": "Dodanie TanStack Query, Zustand, Socket.io client i innych kluczowych bibliotek",
            "dependencies": [
              1
            ],
            "details": "W folderze frontend uruchom `npm install @tanstack/react-query zustand socket.io-client react-hook-form zod framer-motion lucide-react`. Sprawdź czy wszystkie pakiety zostały poprawnie zainstalowane i zapisane w package.json",
            "status": "done",
            "testStrategy": "Sprawdź czy package.json zawiera wszystkie wymienione biblioteki w dependencies, node_modules została utworzona poprawnie",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:38:02.153Z"
          },
          {
            "id": 3,
            "title": "Konfiguracja struktury folderów w src/",
            "description": "Utworzenie podstawowej struktury katalogów dla organizacji kodu frontend",
            "dependencies": [
              2
            ],
            "details": "Utwórz następującą strukturę folderów w src/: components/, hooks/, lib/, stores/, types/, utils/. W każdym folderze dodaj index.ts eksportujący zawartość. Skonfiguruj aliasy ścieżek w tsconfig.json jeśli potrzeba",
            "status": "done",
            "testStrategy": "Sprawdź czy wszystkie foldery zostały utworzone, pliki index.ts istnieją w każdym folderze, import aliasy działają poprawnie",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:38:44.321Z"
          },
          {
            "id": 4,
            "title": "Utworzenie Dockerfile dla frontend",
            "description": "Konfiguracja Docker container dla aplikacji Next.js",
            "dependencies": [
              3
            ],
            "details": "Stwórz Dockerfile w folderze frontend z multi-stage build: 1) dependencies stage z npm install, 2) build stage z npm run build, 3) production stage z optimized image. Dodaj .dockerignore z node_modules, .git, .next itp.",
            "status": "done",
            "testStrategy": "Sprawdź czy Dockerfile buduje się bez błędów, .dockerignore zawiera odpowiednie wpisy, image ma odpowiedni rozmiar",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:39:09.261Z"
          },
          {
            "id": 5,
            "title": "Weryfikacja działania aplikacji Next.js",
            "description": "Sprawdzenie czy aplikacja uruchamia się poprawnie i wszystkie konfiguracje działają",
            "dependencies": [
              4
            ],
            "details": "Uruchom `npm run dev` w folderze frontend i sprawdź czy aplikacja startuje na porcie 3000. Sprawdź czy strona główna ładuje się poprawnie, Tailwind CSS działa, import aliasy są rozpoznawane przez TypeScript",
            "status": "done",
            "testStrategy": "Sprawdź czy `npm run dev` uruchamia aplikację bez błędów, strona dostępna na localhost:3000, TypeScript compilation działa poprawnie",
            "parentId": "undefined",
            "updatedAt": "2025-11-06T02:39:42.572Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już odpowiedni podział na 5 subtasków pokrywających setup Next.js, instalację bibliotek UI i state management.",
        "updatedAt": "2025-11-06T02:39:42.572Z"
      },
      {
        "id": "5",
        "title": "Konfiguracja Prisma ORM i bazy danych",
        "description": "Utworzenie schematu Prisma dla wszystkich encji i skonfigurowanie połączenia z PostgreSQL",
        "details": "Wykonaj `npx prisma init` w backend/. Zaprojektuj schema.prisma z encjami: User, Article, BlogPost, WikiPage, GalleryItem, Story, Author, Comment, Rating, Category, Tag, Session, Notification, EmailQueue. Zdefiniuj relacje One-to-Many i Many-to-Many. Dodaj indeksy dla optymalizacji. Utwórz pierwszą migrację.",
        "testStrategy": "Sprawdź czy `npx prisma migrate dev` wykonuje się bez błędów, `npx prisma studio` pokazuje wszystkie tabele, relacje działają poprawnie",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Inicjalizacja Prisma i podstawowa konfiguracja",
            "description": "Wykonanie npx prisma init w folderze backend i konfiguracja podstawowych ustawień",
            "dependencies": [],
            "details": "Uruchom `npx prisma init` w folderze backend/. Skonfiguruj DATABASE_URL w .env. Ustaw podstawowe opcje w schema.prisma: generator client, datasource db postgresql. Zainstaluj @prisma/client i prisma jako dependencje.",
            "status": "done",
            "testStrategy": "Sprawdź czy folder prisma/ został utworzony, schema.prisma zawiera poprawną konfigurację, connection string jest ustawiony",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Projektowanie schema dla encji User i Authentication",
            "description": "Stworzenie modeli User, Session i związanych z autentyfikacją encji",
            "dependencies": [
              1
            ],
            "details": "Zdefiniuj model User (id, email, username, password, role, createdAt, updatedAt). Dodaj model Session dla JWT sessions. Utwórz relacje User-Session. Dodaj indeksy na email, username dla optymalizacji.",
            "status": "done",
            "testStrategy": "Sprawdź czy modele User i Session są poprawnie zdefiniowane, relacje działają, indeksy są utworzone",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Projektowanie schema dla encji treści",
            "description": "Stworzenie modeli Article, BlogPost, WikiPage, GalleryItem, Story, Author",
            "dependencies": [
              2
            ],
            "details": "Zdefiniuj modele treści: Article, BlogPost, WikiPage (z parent-child dla hierarchii), GalleryItem, Story, Author. Ustaw relacje Author-Content (One-to-Many). Dodaj pola: title, content, slug, publishedAt, status. Dodaj indeksy na slug, publishedAt.",
            "status": "done",
            "testStrategy": "Sprawdź czy wszystkie modele treści są zdefiniowane, relacje Author-Content działają, hierarchia WikiPage jest poprawna",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Projektowanie schema dla systemu komentarzy i ocen",
            "description": "Stworzenie modeli Comment, Rating, Category, Tag z relacjami Many-to-Many",
            "dependencies": [
              3
            ],
            "details": "Zdefiniuj Comment (z polimorficznymi relacjami do wszystkich typów treści), Rating (1-5), Category, Tag. Utwórz tabele łączące dla Many-to-Many: ContentCategories, ContentTags. Dodaj indeksy na contentType, contentId, userId.",
            "status": "done",
            "testStrategy": "Sprawdź czy Comment i Rating działają z wszystkimi typami treści, relacje Many-to-Many Category/Tag działają poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Finalizacja schema i pierwsza migracja",
            "description": "Dodanie pozostałych modeli i uruchomienie pierwszej migracji Prisma",
            "dependencies": [
              4
            ],
            "details": "Dodaj modele Notification, EmailQueue. Sprawdź wszystkie relacje i indeksy. Uruchom `npx prisma migrate dev --name init` dla utworzenia pierwszej migracji. Wygeneruj Prisma Client z `npx prisma generate`.",
            "status": "done",
            "testStrategy": "Sprawdź czy migracja wykonuje się bez błędów, wszystkie tabele są utworzone, Prisma Studio pokazuje kompletny schema",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już dobrze podzielone na 5 subtasków obejmujących schema design, migracje i seed data dla wszystkich encji systemu."
      },
      {
        "id": "6",
        "title": "Implementacja modułu autoryzacji JWT",
        "description": "Stworzenie systemu autoryzacji z JWT tokenami, rejestracją i logowaniem",
        "details": "Stwórz AuthModule z AuthController, AuthService. Implementuj Passport JWT strategy, JwtAuthGuard, RolesGuard. Dodaj endpointy: POST /auth/register, POST /auth/login, POST /auth/logout, GET /auth/me, POST /auth/refresh. Zaimplementuj hashowanie haseł bcrypt. Konfiguruj Redis dla sesji.",
        "testStrategy": "Sprawdź czy rejestracja tworzy użytkownika, logowanie zwraca token JWT, chronione endpointy wymagają autoryzacji, role-based access działa",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie AuthModule z AuthController i AuthService",
            "description": "Implementacja podstawowej struktury modułu autoryzacji z kontrolerem i serwisem do obsługi logiki biznesowej",
            "dependencies": [],
            "details": "Stwórz AuthModule z dekoratorem @Module, AuthController z dekoratorami @Controller i endpointami, AuthService z logiką rejestracji/logowania. Skonfiguruj dependency injection między serwisem a kontrolerem. Dodaj podstawowe DTOs: RegisterDto, LoginDto z walidacją class-validator.",
            "status": "pending",
            "testStrategy": "Unit testy dla AuthService metod register/login, integracyjne testy dla AuthController endpointów",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja Passport JWT strategy i konfiguracji",
            "description": "Skonfigurowanie strategii JWT z biblioteką Passport dla autoryzacji tokenowej",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj @nestjs/passport, @nestjs/jwt, passport-jwt. Stwórz JwtStrategy extends PassportStrategy, skonfiguruj JWT_SECRET w ConfigService. Dodaj JwtModule.forRootAsync z konfiguracją expiration time, secret. Implementuj validate() metodę w JwtStrategy.",
            "status": "pending",
            "testStrategy": "Testy czy JWT strategy poprawnie waliduje tokeny, sprawdź expiration handling",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie JwtAuthGuard i RolesGuard",
            "description": "Implementacja guardów do ochrony endpointów i kontroli dostępu opartej na rolach",
            "dependencies": [
              2
            ],
            "details": "Stwórz JwtAuthGuard extends AuthGuard('jwt'), RolesGuard implements CanActivate. Dodaj @Roles() dekorator dla role-based access control. Implementuj logikę sprawdzania ról w RolesGuard. Skonfiguruj guards globalnie lub per-controller.",
            "status": "pending",
            "testStrategy": "Testy czy protected endpointy wymagają autoryzacji, role-based access control działa poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja hashowania haseł z bcrypt",
            "description": "Dodanie bezpiecznego hashowania i weryfikacji haseł przy użyciu biblioteki bcrypt",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj bcrypt i @types/bcrypt. Dodaj metody hashPassword() i comparePassword() w AuthService. Implementuj salt rounds (12). Dodaj hashowanie przy rejestracji i weryfikację przy logowaniu. Obsłuż błędy hashowania.",
            "status": "pending",
            "testStrategy": "Sprawdź czy hasła są hashowane przed zapisem, compare działa dla poprawnych/błędnych haseł",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Konfiguracja endpointów autoryzacji i Redis dla sesji",
            "description": "Implementacja wszystkich endpointów API autoryzacji i konfiguracja Redis do zarządzania sesjami",
            "dependencies": [
              3,
              4
            ],
            "details": "Dodaj endpointy: POST /auth/register, POST /auth/login (zwraca JWT), POST /auth/logout, GET /auth/me (protected), POST /auth/refresh. Skonfiguruj Redis z @nestjs/redis dla session management. Implementuj refresh token logic z blacklisting.",
            "status": "pending",
            "testStrategy": "E2E testy wszystkich endpointów, sprawdź czy logout invaliduje token, refresh token workflow działa",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już bardzo dobry podział na 5 subtasków pokrywających AuthModule, JWT Strategy, Guards, hashowanie haseł i Redis integration.",
        "updatedAt": "2025-11-06T16:22:25.663Z"
      },
      {
        "id": "7",
        "title": "Implementacja modułu Articles",
        "description": "Stworzenie pełnego CRUD dla artykułów z paginacją i filtrowaniem",
        "details": "Stwórz ArticlesModule z ArticlesController, ArticlesService. Implementuj endpointy: GET /articles (lista z paginacją), GET /articles/:id, POST /articles (admin), PUT /articles/:id (admin), DELETE /articles/:id (admin). Dodaj filtering po kategoriach, tagach. Implementuj CreateArticleDto, UpdateArticleDto z validacją.",
        "testStrategy": "Sprawdź czy wszystkie CRUD operacje działają, paginacja zwraca właściwą liczbę rekordów, filtering po kategoriach/tagach działa, autoryzacja admin jest wymagana",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie struktury ArticlesModule",
            "description": "Stworzenie podstawowej struktury modułu Articles z kontrolerem i serwisem",
            "dependencies": [],
            "details": "Utworzenie plików articles.module.ts, articles.controller.ts, articles.service.ts. Zaimportowanie modułu w głównym AppModule. Skonfigurowanie podstawowej struktury z dependency injection.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy moduł się kompiluje i ładuje bez błędów",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja DTOs z walidacją",
            "description": "Stworzenie CreateArticleDto i UpdateArticleDto z kompletnymi regułami walidacji",
            "dependencies": [
              1
            ],
            "details": "Utworzenie plików dto/create-article.dto.ts i dto/update-article.dto.ts. Implementacja walidacji z class-validator (@IsString, @IsNotEmpty, @IsOptional, @IsArray). Dodanie transformacji dla kategorii i tagów.",
            "status": "pending",
            "testStrategy": "Testy jednostkowe walidacji DTOs - sprawdzenie czy nieprawidłowe dane są odrzucane",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja endpointów CRUD",
            "description": "Stworzenie wszystkich endpointów CRUD dla artykułów z autoryzacją admin",
            "dependencies": [
              2
            ],
            "details": "Implementacja GET /articles/:id, POST /articles, PUT /articles/:id, DELETE /articles/:id w ArticlesController. Dodanie guards dla autoryzacji admin (@UseGuards(JwtAuthGuard, RolesGuard)). Obsługa błędów i response statusów.",
            "status": "pending",
            "testStrategy": "Testy e2e wszystkich endpointów - sprawdzenie autoryzacji, response codes, obsługi błędów",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja listy artykułów z paginacją",
            "description": "Stworzenie endpoint GET /articles z paginacją i podstawowym sortowaniem",
            "dependencies": [
              3
            ],
            "details": "Implementacja GET /articles z query parameters: page, limit, sortBy, order. Użycie TypeORM pagination (take, skip). Zwracanie metadanych paginacji (total, pages, currentPage). Domyślne sortowanie po dacie utworzenia.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy paginacja zwraca właściwą liczbę rekordów, metadane są poprawne, sortowanie działa",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja filtrowania po kategoriach i tagach",
            "description": "Dodanie zaawansowanego filtrowania artykułów po kategoriach, tagach i wyszukiwaniu tekstowym",
            "dependencies": [
              4
            ],
            "details": "Rozszerzenie GET /articles o query parameters: categories, tags, search. Implementacja QueryBuilder z JOIN dla kategorii/tagów. Dodanie full-text search w tytule i treści. Kombinowanie filtrów z operatorem AND/OR.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy filtering po kategoriach/tagach zwraca właściwe wyniki, wyszukiwanie tekstowe działa, kombinowanie filtrów jest poprawne",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już właściwie podzielone na 5 subtasków obejmujących module setup, DTOs, CRUD endpoints i integrację z kategoriami.",
        "updatedAt": "2025-11-06T16:42:45.862Z"
      },
      {
        "id": "8",
        "title": "Implementacja modułu BlogPosts",
        "description": "Stworzenie systemu blog postów z funkcjonalnościami podobnymi do Articles",
        "details": "Stwórz BlogPostsModule z pełnym CRUD. Implementuj endpointy: GET /blog, GET /blog/:id, POST /blog, PUT /blog/:id, DELETE /blog/:id. Dodaj support dla kategorii, tagów, paginacji. Implementuj DTOs z walidacją class-validator.",
        "testStrategy": "Sprawdź czy blog posts można tworzyć, edytować, usuwać, lista zwraca posty z paginacją, filtering działa",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie BlogPost entity i BlogPostsModule",
            "description": "Stworzenie podstawowej struktury modułu blog postów z entity i modułem",
            "dependencies": [],
            "details": "Stwórz BlogPost entity z polami: id, title, content, excerpt, slug, categories, tags, authorId, createdAt, updatedAt, publishedAt. Dodaj BlogPostsModule, BlogPostsController, BlogPostsService. Skonfiguruj TypeORM relationships z User (author), Categories, Tags.",
            "status": "pending",
            "testStrategy": "Sprawdź czy entity jest poprawnie zdefiniowana, relacje działają, moduł się kompiluje",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja DTOs i walidacji",
            "description": "Stworzenie DTOs dla operacji CRUD z walidacją class-validator",
            "dependencies": [
              1
            ],
            "details": "Implementuj CreateBlogPostDto z walidacją: title (wymagane, 5-200 znaków), content (wymagane, min 50 znaków), excerpt (opcjonalne, max 300 znaków), categories, tags. Stwórz UpdateBlogPostDto, BlogPostResponseDto z transformacją danych.",
            "status": "pending",
            "testStrategy": "Sprawdź czy walidacja odrzuca niepoprawne dane, DTOs transformują dane poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja operacji CRUD w service",
            "description": "Stworzenie logiki biznesowej dla zarządzania blog postami",
            "dependencies": [
              2
            ],
            "details": "Implementuj w BlogPostsService: findAll() z paginacją i filtrowaniem, findOne(), create(), update(), remove(). Dodaj automatyczne generowanie slug z title, obsługę kategorii i tagów, soft delete. Implementuj query builder dla zaawansowanego filtrowania.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie operacje CRUD działają, slug generuje się automatycznie, filtrowanie po kategoriach/tagach działa",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja endpointów REST API",
            "description": "Stworzenie kontrolera z pełnym zestawem endpointów dla blog postów",
            "dependencies": [
              3
            ],
            "details": "Implementuj w BlogPostsController: GET /blog (lista z query params: page, limit, category, tag, search), GET /blog/:slug, POST /blog (admin only), PUT /blog/:id (admin only), DELETE /blog/:id (admin only). Dodaj proper HTTP status codes, error handling, autoryzację admin dla operacji modyfikujących.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie endpointy zwracają poprawne responses, autoryzacja admin działa, error handling jest prawidłowe",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Dodanie paginacji i zaawansowanego filtrowania",
            "description": "Implementacja paginacji i systemów filtrowania dla listy blog postów",
            "dependencies": [
              4
            ],
            "details": "Implementuj PaginationDto z page, limit, sort, order. Dodaj FiltersDto z category, tag, author, dateFrom, dateTo, search. Implementuj search po title, content, excerpt. Dodaj meta informacje w response (totalItems, totalPages, currentPage).",
            "status": "pending",
            "testStrategy": "Sprawdź czy paginacja zwraca właściwą liczbę rekordów, filtrowanie działa dla wszystkich parametrów, search znajduje właściwe posty, meta informacje są poprawne",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już odpowiedni podział na 5 subtasków, podobny do modułu Articles ale z mniejszą złożonością.",
        "updatedAt": "2025-11-06T16:48:11.993Z"
      },
      {
        "id": "9",
        "title": "Implementacja modułu WikiPages z hierarchią",
        "description": "Stworzenie systemu wiki z hierarchiczną strukturą parent-child",
        "details": "Stwórz WikiPagesModule z support dla hierarchicznej struktury. Dodaj pole parentId w WikiPage encji. Implementuj endpointy: GET /wiki (tree structure), GET /wiki/:id, POST /wiki, PUT /wiki/:id, DELETE /wiki/:id. Dodaj recursive queries dla tree navigation.",
        "testStrategy": "Sprawdź czy strony wiki można organizować hierarchicznie, tree navigation działa, parent-child relacje są poprawne",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie WikiPage encji z hierarchiczną strukturą",
            "description": "Utworzenie encji TypeORM dla WikiPage z polem parentId do obsługi relacji parent-child",
            "dependencies": [],
            "details": "Stwórz WikiPage encję z polami: id, title, content, parentId (nullable), createdAt, updatedAt, authorId. Dodaj @ManyToOne relację do parent i @OneToMany do children. Skonfiguruj nullable parentId dla root pages. Dodaj indeksy na parentId dla wydajności.",
            "status": "pending",
            "testStrategy": "Sprawdź czy encja tworzy poprawną strukturę tabeli, relacje parent-child działają, można tworzyć root pages (parentId=null)",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja WikiPagesService z recursive queries",
            "description": "Stworzenie serwisu z metodami do obsługi hierarchicznych zapytań i budowania drzewa",
            "dependencies": [
              1
            ],
            "details": "Implementuj metody: findTree() - zwraca pełną strukturę drzewa, findById() z children, findByParentId(), createWikiPage(), updateWikiPage(), deleteWikiPage() z cascading children. Użyj TypeORM TreeRepository lub custom recursive queries z CTE.",
            "status": "pending",
            "testStrategy": "Sprawdź czy findTree() zwraca poprawną hierarchię, recursive queries działają wydajnie, cascading delete zachowuje się poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie WikiPagesController z endpointami",
            "description": "Implementacja REST API endpointów dla operacji CRUD na wiki pages",
            "dependencies": [
              2
            ],
            "details": "Implementuj endpointy: GET /wiki (tree structure), GET /wiki/:id (z children), POST /wiki (z parentId), PUT /wiki/:id, DELETE /wiki/:id. Dodaj guards dla autoryzacji admin. Implementuj DTOs: CreateWikiPageDto, UpdateWikiPageDto z walidacją.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie endpointy działają, autoryzacja jest wymagana dla CUD operacji, DTOs walidują dane poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja tree navigation i breadcrumbs",
            "description": "Dodanie funkcjonalności nawigacji po drzewie i ścieżek breadcrumb",
            "dependencies": [
              3
            ],
            "details": "Implementuj metody: getAncestors() - zwraca ścieżkę do root, getSiblings(), getDescendants(). Dodaj endpoint GET /wiki/:id/breadcrumbs dla frontend navigation. Zoptymalizuj queries używając WITH RECURSIVE lub similar.",
            "status": "pending",
            "testStrategy": "Sprawdź czy breadcrumbs pokazują poprawną ścieżkę, navigation po siblings działa, wydajność queries jest akceptowalna",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Stworzenie WikiPagesModule i integracja",
            "description": "Stworzenie modułu NestJS i integracja z aplikacją",
            "dependencies": [
              4
            ],
            "details": "Stwórz WikiPagesModule importując TypeOrmModule.forFeature([WikiPage]). Zarejestruj controller i service. Dodaj do AppModule imports. Skonfiguruj swagger decorators dla API documentation.",
            "status": "pending",
            "testStrategy": "Sprawdź czy moduł ładuje się poprawnie, wszystkie zależności są resolved, swagger generuje poprawną dokumentację API",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już dobrze podzielone na 5 subtasków obejmujących hierarchiczną strukturę, recursive queries i tree navigation.",
        "updatedAt": "2025-11-06T16:56:29.607Z"
      },
      {
        "id": "10",
        "title": "Implementacja modułu GalleryItems z upload plików",
        "description": "Stworzenie galerii z uploadem i przetwarzaniem plików multimedialnych",
        "details": "Stwórz GalleryItemsModule z FileUploadService. Zintegruj Multer dla upload, Sharp dla przetwarzania obrazów, MinIO dla storage. Implementuj generowanie multiple rozmiarów (thumbnail, medium, large), konwersję do WebP, EXIF removal. Dodaj endpointy: GET /gallery, GET /gallery/:id, POST /gallery/upload, DELETE /gallery/:id.",
        "testStrategy": "Sprawdź czy upload plików działa, obrazy są przetwarzane do różnych rozmiarów, WebP conversion działa, pliki są zapisywane w MinIO",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie GalleryItemsModule i FileUploadService",
            "description": "Stworzenie podstawowego modułu galerii z serwisem do obsługi uploadów plików",
            "dependencies": [],
            "details": "Stwórz GalleryItemsModule, GalleryItemsController, GalleryItemsService i FileUploadService. Skonfiguruj podstawową strukturę modułu z dependency injection. Dodaj GalleryItem entity z polami: id, filename, originalName, mimetype, size, path, createdAt, updatedAt.",
            "status": "pending",
            "testStrategy": "Sprawdź czy moduł ładuje się poprawnie, dependency injection działa, entity jest zarejestrowana w TypeORM",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integracja Multer dla uploadu plików",
            "description": "Konfiguracja middleware Multer do obsługi uploadu plików multimedialnych",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj multer i @types/multer. Skonfiguruj MulterModule z opcjami: file size limit (10MB), accepted mimetypes (image/*, video/*), storage configuration. Implementuj POST /gallery/upload endpoint z multer middleware. Dodaj walidację typu pliku i rozmiaru.",
            "status": "pending",
            "testStrategy": "Sprawdź czy pliki można uploadować, walidacja typu pliku działa, limit rozmiaru jest respektowany, błędne pliki są odrzucane",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja przetwarzania obrazów z Sharp",
            "description": "Dodanie automatycznego przetwarzania uploadowanych obrazów do różnych rozmiarów i formatów",
            "dependencies": [
              2
            ],
            "details": "Zainstaluj sharp. Implementuj ImageProcessingService z metodami: generateThumbnail (150x150), generateMedium (800x600), generateLarge (1920x1080). Dodaj konwersję do WebP, usuwanie EXIF data. Stwórz pipeline przetwarzania po uploadziei zapisywanie wszystkich wersji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy obrazy są generowane w trzech rozmiarach, konwersja do WebP działa, EXIF jest usuwane, quality compression jest poprawna",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integracja MinIO dla storage plików",
            "description": "Konfiguracja MinIO S3-compatible storage dla przechowywania plików galerii",
            "dependencies": [
              3
            ],
            "details": "Zainstaluj minio client. Skonfiguruj MinioService z connection do MinIO server. Implementuj uploadToMinio(), deleteFromMinio(), getFileUrl() metody. Stwórz bucket structure: /originals, /thumbnails, /medium, /large. Zaktualizuj FileUploadService aby używać MinIO zamiast local storage.",
            "status": "pending",
            "testStrategy": "Sprawdź czy pliki są zapisywane w MinIO, bucket structure jest poprawna, URL generation działa, usuwanie plików działa",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja CRUD endpointów galerii",
            "description": "Stworzenie pełnych endpointów REST API dla zarządzania elementami galerii",
            "dependencies": [
              4
            ],
            "details": "Implementuj GET /gallery (lista z paginacją, filtering), GET /gallery/:id (pojedynczy element), DELETE /gallery/:id (admin only). Dodaj CreateGalleryItemDto, UpdateGalleryItemDto. Implementuj soft delete, metadata extraction. Dodaj search po filename, filtering po mimetype.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie endpointy działają, paginacja zwraca poprawne dane, autoryzacja admin jest wymagana, soft delete działa, search i filtering działają",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już bardzo dobrą strukturę 5 subtasków pokrywającą upload, processing, MinIO integration i walidację plików."
      },
      {
        "id": "11",
        "title": "Implementacja modułu Stories",
        "description": "Stworzenie systemu opowiadań z supportem dla serii",
        "details": "Stwórz StoriesModule z pełnym CRUD. Dodaj pole seriesId dla grupowania opowiadań w serie. Implementuj endpointy: GET /stories, GET /stories/:id, POST /stories, PUT /stories/:id, DELETE /stories/:id. Dodaj filtering po seriach, autorach.",
        "testStrategy": "Sprawdź czy opowiadania można grupować w serie, CRUD operacje działają, filtering po seriach działa",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie Story entity i migracji bazy danych",
            "description": "Zdefiniowanie encji Story z polami: id, title, content, seriesId, authorId, categories, tags, createdAt, updatedAt",
            "dependencies": [],
            "details": "Stwórz Story entity z dekoratorami TypeORM. Dodaj pole seriesId jako opcjonalne dla grupowania opowiadań w serie. Skonfiguruj relacje z Authors, Categories, Tags. Wygeneruj i uruchom migrację bazy danych.",
            "status": "pending",
            "testStrategy": "Sprawdź czy migracja tworzy poprawną tabelę, relacje działają, można zapisywać i odczytywać dane",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja StoriesService z logiką biznesową",
            "description": "Stworzenie service layer z metodami CRUD i funkcjami pomocniczymi dla operacji na opowiadaniach",
            "dependencies": [
              1
            ],
            "details": "Implementuj StoriesService z metodami: findAll() (z paginacją i filtrowaniem), findOne(), create(), update(), remove(). Dodaj filtering po seriach, autorach, kategoriach. Użyj QueryBuilder dla zaawansowanych zapytań.",
            "status": "pending",
            "testStrategy": "Unit testy dla każdej metody service, sprawdź czy filtering i paginacja działają poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie DTOs z walidacją dla Stories",
            "description": "Definicja CreateStoryDto i UpdateStoryDto z class-validator dla bezpiecznej walidacji danych wejściowych",
            "dependencies": [
              1
            ],
            "details": "Stwórz CreateStoryDto z walidacją: title (wymagane, min 5 znaków), content (wymagane, min 50 znaków), seriesId (opcjonalne), authorId (wymagane), categories, tags. UpdateStoryDto jako Partial z CreateStoryDto.",
            "status": "pending",
            "testStrategy": "Sprawdź czy walidacja odrzuca niepoprawne dane, poprawne dane przechodzą walidację",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja StoriesController z endpointami API",
            "description": "Stworzenie kontrolera z pełnym CRUD i autoryzacją dla operacji administracyjnych",
            "dependencies": [
              2,
              3
            ],
            "details": "Implementuj StoriesController z endpointami: GET /stories (publiczny z paginacją), GET /stories/:id (publiczny), POST /stories (admin), PUT /stories/:id (admin), DELETE /stories/:id (admin). Dodaj guards dla autoryzacji admin.",
            "status": "pending",
            "testStrategy": "Testy integracyjne dla każdego endpointu, sprawdź autoryzację admin, response codes, paginację",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Konfiguracja StoriesModule i integracja z główną aplikacją",
            "description": "Połączenie wszystkich komponentów w module i rejestracja w głównym AppModule",
            "dependencies": [
              4
            ],
            "details": "Stwórz StoriesModule importując TypeOrmModule.forFeature([Story]), rejestruj StoriesController i StoriesService. Dodaj do imports w AppModule. Skonfiguruj routing i swagger documentation.",
            "status": "pending",
            "testStrategy": "E2E testy całego flow, sprawdź czy module ładuje się poprawnie, swagger docs są dostępne",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już odpowiedni podział na 5 subtasków, podobny do poprzednich content modules ale z dodatkowym series grouping."
      },
      {
        "id": "12",
        "title": "Implementacja modułu Authors",
        "description": "Stworzenie systemu profili autorów z biografiami i zdjęciami",
        "details": "Stwórz AuthorsModule z AuthorsController, AuthorsService. Implementuj profile autorów z polami: name, bio, profileImage, contactInfo, socialLinks. Dodaj endpointy: GET /authors, GET /authors/:id, POST /authors, PUT /authors/:id, DELETE /authors/:id. Integruj z upload zdjęć profilowych.",
        "testStrategy": "Sprawdź czy profile autorów można tworzyć i edytować, zdjęcia profilowe się uploadują, lista autorów wyświetla się poprawnie",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie entity Author z relacjami",
            "description": "Implementacja encji Author z wszystkimi polami i relacjami do innych encji",
            "dependencies": [],
            "details": "Stwórz entity Author z polami: id, name, bio, profileImage, contactInfo, socialLinks, createdAt, updatedAt. Dodaj relacje @OneToMany do Articles, BlogPosts, Stories. Skonfiguruj TypeORM decoratory i walidacje. Ustaw cascade options i foreign keys.",
            "status": "pending",
            "testStrategy": "Sprawdź czy entity ma wszystkie pola, relacje są poprawnie skonfigurowane, migracja bazy danych przebiega bez błędów",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja AuthorsService z metodami CRUD",
            "description": "Stworzenie serwisu do zarządzania autorami z pełnym CRUD i logiką biznesową",
            "dependencies": [
              1
            ],
            "details": "Implementuj AuthorsService z metodami: findAll(), findOne(), create(), update(), remove(). Dodaj QueryBuilder dla paginacji i filtrowania. Implementuj logikę walidacji danych, obsługę błędów i relacji z treściami. Dodaj soft delete dla authorów.",
            "status": "pending",
            "testStrategy": "Unit testy dla wszystkich metod CRUD, sprawdzenie poprawności zapytań do bazy, walidacji i obsługi błędów",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie AuthorsController z endpointami API",
            "description": "Implementacja kontrolera z pełnym API REST dla autorów",
            "dependencies": [
              2
            ],
            "details": "Stwórz AuthorsController z endpointami: GET /authors (z paginacją), GET /authors/:id, POST /authors (admin), PUT /authors/:id (admin), DELETE /authors/:id (admin). Dodaj guards dla autoryzacji, DTOs dla walidacji, Swagger dokumentację. Implementuj error handling.",
            "status": "pending",
            "testStrategy": "Testy integracyjne dla wszystkich endpointów, sprawdzenie autoryzacji admin, walidacji danych wejściowych",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja upload systemu dla zdjęć profilowych",
            "description": "Stworzenie systemu upload zdjęć profilowych autorów z optymalizacją",
            "dependencies": [
              3
            ],
            "details": "Zainstaluj multer, sharp. Stwórz upload middleware dla zdjęć profilowych. Implementuj resizing obrazków (200x200, 400x400), walidację typu pliku, ograniczenie rozmiaru. Dodaj endpoint PATCH /authors/:id/avatar. Skonfiguruj storage (lokalny lub cloud).",
            "status": "pending",
            "testStrategy": "Sprawdź czy upload działa, obrazki są resizowane, walidacja typu pliku działa, stare zdjęcia są usuwane przy update",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integracja AuthorsModule z aplikacją i testowanie",
            "description": "Finalna integracja modułu autorów z całą aplikacją i kompletne testowanie",
            "dependencies": [
              4
            ],
            "details": "Dodaj AuthorsModule do AppModule. Skonfiguruj relacje z Articles, BlogPosts, Stories modules. Stwórz migration dla bazy danych. Dodaj seeder dla przykładowych autorów. Sprawdź integrację z frontend, popraw błędy, zoptymalizuj zapytania.",
            "status": "pending",
            "testStrategy": "E2E testy całego flow autorów, sprawdzenie integracji z innymi modułami, performance testing, seed data verification",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już właściwie podzielone na 5 subtasków obejmujących entity, service, controller, upload zdjęć i integrację z modułami."
      },
      {
        "id": "13",
        "title": "Implementacja polymorphicznego systemu komentarzy",
        "description": "Stworzenie uniwersalnego systemu komentarzy dla wszystkich typów treści",
        "details": "Stwórz CommentsModule z polymorphic design. Dodaj pola: contentType, contentId, userId, text, parentId (dla nested comments). Implementuj endpointy: GET /comments?contentType=article&contentId=1, POST /comments, DELETE /comments/:id. Dodaj support dla nested replies i moderacji.",
        "testStrategy": "Sprawdź czy komentarze działają dla Articles, BlogPosts, WikiPages, GalleryItems, Stories, nested replies działają, moderacja dla admin działa",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie Comment entity z polymorphic design",
            "description": "Utworzenie encji Comment z polami contentType, contentId, userId, text, parentId dla obsługi wszystkich typów treści",
            "dependencies": [],
            "details": "Stwórz Comment entity w TypeORM z polami: id (primary), contentType (enum: 'article', 'blog', 'wiki', 'gallery', 'story'), contentId (foreign key), userId (relation do User), text (varchar), parentId (self-reference), createdAt, updatedAt. Dodaj indeksy na contentType+contentId i parentId dla wydajności zapytań.",
            "status": "pending",
            "testStrategy": "Sprawdź czy entity jest poprawnie utworzona, relacje działają, indeksy są utworzone, można zapisać komentarze dla różnych typów treści",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja CommentsModule, Controller i Service",
            "description": "Stworzenie modułu komentarzy z kontrolerem i serwisem obsługującym logikę biznesową",
            "dependencies": [
              1
            ],
            "details": "Stwórz CommentsModule, CommentsController, CommentsService. Implementuj metody serwisu: findByContent(contentType, contentId), create(createCommentDto), findReplies(parentId), delete(id), moderateComment(id, action). Dodaj CreateCommentDto, UpdateCommentDto z walidacją class-validator.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie metody serwisu działają poprawnie, DTOs walidują dane, dependency injection działa",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja endpointów API dla komentarzy",
            "description": "Stworzenie REST API endpointów do zarządzania komentarzami z autoryzacją",
            "dependencies": [
              2
            ],
            "details": "Implementuj endpointy: GET /comments?contentType=X&contentId=Y (publiczny), POST /comments (wymaga auth), DELETE /comments/:id (autor lub admin), GET /comments/:id/replies (publiczny). Dodaj JwtGuard dla operacji wymagających autoryzacji, RolesGuard dla moderacji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy endpointy zwracają poprawne dane, autoryzacja działa, filtering po contentType/contentId działa, błędy są poprawnie obsługiwane",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja nested replies i hierarchii komentarzy",
            "description": "Obsługa zagnieżdżonych odpowiedzi na komentarze z limitem głębokości",
            "dependencies": [
              3
            ],
            "details": "Rozszerz CommentsService o obsługę zagnieżdżonych komentarzy: buildCommentTree(comments), validateNestingDepth(parentId, maxDepth=3). Implementuj rekurencyjne ładowanie replies, optymalizuj zapytania z eager loading. Dodaj endpoint GET /comments/:id/tree dla pełnego drzewa.",
            "status": "pending",
            "testStrategy": "Sprawdź czy nested replies działają do 3 poziomów, drzewo komentarzy jest poprawnie budowane, wydajność zapytań jest akceptowalna",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "System moderacji komentarzy dla adminów",
            "description": "Implementacja funkcji moderacyjnych - usuwanie, ukrywanie, zatwierdzanie komentarzy",
            "dependencies": [
              4
            ],
            "details": "Dodaj pola do Comment: isHidden, isApproved, moderatedBy, moderatedAt. Implementuj CommentModerationService z metodami: hideComment(), approveComment(), deleteComment(), getModerationQueue(). Dodaj admin endpointy: PUT /admin/comments/:id/moderate, GET /admin/comments/moderation-queue.",
            "status": "pending",
            "testStrategy": "Sprawdź czy tylko admini mogą moderować, ukryte komentarze nie są widoczne publicznie, kolejka moderacji działa, audit trail jest zapisywany",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już bardzo dobry podział na 5 subtasków pokrywających polymorphic design, nested replies i moderację."
      },
      {
        "id": "14",
        "title": "Implementacja systemu ocen (ratings)",
        "description": "Stworzenie systemu ocen 1-5 gwiazdek dla wszystkich typów treści",
        "details": "Stwórz RatingsModule z polymorphic design podobnym do Comments. Dodaj pola: contentType, contentId, userId, rating (1-5). Implementuj constraint unique per user per content. Dodaj endpointy: GET /ratings, POST /ratings, PUT /ratings/:id. Implementuj kalkulację średniej oceny.",
        "testStrategy": "Sprawdź czy oceny można dodawać dla wszystkich content types, jeden użytkownik może ocenić raz, średnia ocena kalkuluje się poprawnie",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Utworzenie encji Rating z polymorphic design",
            "description": "Implementacja encji Rating z polami contentType, contentId, userId, rating i relacjami do User",
            "dependencies": [],
            "details": "Stwórz Rating entity z dekoratorami TypeORM: contentType (enum), contentId (number), userId (relacja do User), rating (1-5, validacja). Dodaj unique constraint na userId+contentType+contentId. Dodaj timestamps (createdAt, updatedAt).",
            "status": "pending",
            "testStrategy": "Unit testy dla Rating entity, sprawdzenie unique constraint, walidacja rating 1-5",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja RatingsController z endpointami CRUD",
            "description": "Stworzenie kontrolera z endpointami GET /ratings, POST /ratings, PUT /ratings/:id",
            "dependencies": [
              1
            ],
            "details": "Implementuj RatingsController z metodami: getRatings() z paginacją i filterowaniem, createRating() z validacją, updateRating() dla aktualizacji własnych ocen. Dodaj guards dla autoryzacji użytkowników.",
            "status": "pending",
            "testStrategy": "Integration testy dla wszystkich endpointów, sprawdzenie autoryzacji, walidacja input data",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja RatingsService z logiką biznesową",
            "description": "Serwis z metodami do zarządzania ocenami i kalkulacji średniej",
            "dependencies": [
              1
            ],
            "details": "Stwórz RatingsService z metodami: findRatingsByContent(), createRating() z sprawdzaniem duplikatów, updateUserRating(), calculateAverageRating(). Implementuj caching dla średnich ocen używając Redis lub in-memory cache.",
            "status": "pending",
            "testStrategy": "Unit testy dla wszystkich metod serwisu, sprawdzenie kalkulacji średniej, testy cache",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Utworzenie DTOs i walidacji dla ratings",
            "description": "Implementacja CreateRatingDto, UpdateRatingDto z walidatorami class-validator",
            "dependencies": [],
            "details": "Stwórz CreateRatingDto z polami contentType, contentId, rating. UpdateRatingDto tylko z rating. Dodaj dekoratory @IsEnum, @IsNumber, @Min(1), @Max(5), @IsNotEmpty. Stwórz response DTOs z average rating.",
            "status": "pending",
            "testStrategy": "Unit testy walidacji DTOs, sprawdzenie rejection dla niepoprawnych danych",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integracja systemu ocen z modułami content",
            "description": "Dodanie pól averageRating do encji treści i aktualizacja po dodaniu oceny",
            "dependencies": [
              2,
              3
            ],
            "details": "Dodaj pole averageRating do Article, BlogPost, WikiPage, Story, GalleryItem. Implementuj event listener lub hook do automatycznej aktualizacji średniej po dodaniu/zmianie oceny. Stwórz migration dla nowych pól.",
            "status": "pending",
            "testStrategy": "Integration testy sprawdzające automatyczne aktualizowanie averageRating w content entities",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już dobrze podzielone na 5 subtasków obejmujących polymorphic ratings, unique constraints i kalkulację średniej."
      },
      {
        "id": "15",
        "title": "Konfiguracja Redis i cache service",
        "description": "Implementacja systemu cachowania z Redis dla optymalizacji performance",
        "details": "Stwórz CacheModule z RedisService. Skonfiguruj @nestjs/cache-manager z redis store. Implementuj cache dla często pobieranych danych: popular articles, trending content, search results. Dodaj TTL configuration i cache invalidation strategies.",
        "testStrategy": "Sprawdź czy Redis connection działa, cache zapisuje i odczytuje dane, TTL expiration działa, performance queries poprawia się",
        "priority": "medium",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalacja i konfiguracja Redis w Docker Compose",
            "description": "Dodanie Redis kontenera do docker-compose.yml i konfiguracja podstawowych ustawień",
            "dependencies": [],
            "details": "Dodaj Redis service do docker-compose.yml z odpowiednimi portami (6379), volumens dla persistence, konfiguracja memory limits i podstawowe Redis settings. Skonfiguruj Redis w trybie standalone z włączoną persistence.",
            "status": "pending",
            "testStrategy": "Sprawdź czy Redis kontener uruchamia się poprawnie, połączenie działa przez redis-cli, persistence zapisuje dane po restarcie",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Utworzenie CacheModule w NestJS",
            "description": "Implementacja dedykowanego modułu cachowania z konfiguracją Redis store",
            "dependencies": [
              1
            ],
            "details": "Stwórz CacheModule z @nestjs/cache-manager, skonfiguruj Redis store adapter, zdefiniuj CacheService z metodami get/set/del. Dodaj konfigurację connection pool, timeout settings i error handling dla Redis.",
            "status": "pending",
            "testStrategy": "Sprawdź czy CacheModule inicjalizuje się poprawnie, połączenie z Redis działa, podstawowe operacje cache działają bez błędów",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja cache strategies dla content",
            "description": "Dodanie cachowania dla popular articles, trending content i search results",
            "dependencies": [
              2
            ],
            "details": "Implementuj cache decorators i interceptors dla często pobieranych danych. Dodaj cache dla popular articles (klucz: 'popular:articles'), trending content (klucz: 'trending'), search results (klucz: 'search:{query}'). Użyj cache-aside pattern.",
            "status": "pending",
            "testStrategy": "Sprawdź czy dane cachują się poprawnie, cache hit/miss działa zgodnie z oczekiwaniami, różne typy content mają odpowiednie klucze",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Konfiguracja TTL i expiration policies",
            "description": "Ustawienie Time-To-Live dla różnych typów danych w cache",
            "dependencies": [
              3
            ],
            "details": "Skonfiguruj różne TTL dla różnych typów danych: articles (1 godzina), trending content (30 minut), search results (15 minut). Implementuj configurable TTL przez environment variables. Dodaj automatic cleanup expired keys.",
            "status": "pending",
            "testStrategy": "Sprawdź czy TTL ustawia się poprawnie dla każdego typu danych, expired keys są automatycznie usuwane, TTL można konfigurować przez env vars",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja cache invalidation strategies",
            "description": "Dodanie mechanizmów invalidacji cache przy aktualizacji danych",
            "dependencies": [
              4
            ],
            "details": "Implementuj cache invalidation hooks w service layer. Dodaj tag-based invalidation dla powiązanych danych (np. invalidacja popular articles gdy nowy article jest published). Stwórz CacheInvalidationService z metodami clearByPattern i clearByTags.",
            "status": "pending",
            "testStrategy": "Sprawdź czy cache invaliduje się poprawnie przy update operations, tag-based invalidation działa, performance nie degraduje się przez invalidation",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już właściwą strukturę 5 subtasków pokrywających Redis setup, cache strategies i TTL configuration."
      },
      {
        "id": "16",
        "title": "Integracja Socket.io dla real-time funkcjonalności",
        "description": "Implementacja WebSocket połączeń dla live notifications i updates",
        "details": "Zainstaluj @nestjs/websockets, socket.io. Stwórz NotificationsGateway z eventami: user-connected, user-disconnected, new-comment, new-rating, live-update. Implementuj rooms dla different content pages. Dodaj JWT authentication dla WebSocket connections.",
        "testStrategy": "Sprawdź czy WebSocket connection się nawiązuje, real-time notifications działają, rooms isolation działa, authentication jest wymagane",
        "priority": "medium",
        "dependencies": [
          "15"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalacja i konfiguracja Socket.io dependencies",
            "description": "Zainstalowanie @nestjs/websockets, @nestjs/platform-socket.io, socket.io i skonfigurowanie podstawowych importów w NestJS",
            "dependencies": [],
            "details": "Wykonaj `npm install @nestjs/websockets @nestjs/platform-socket.io socket.io` w folderze backend. Dodaj WebSocketsModule do app.module.ts. Skonfiguruj podstawowe CORS settings dla WebSocket connections.",
            "status": "pending",
            "testStrategy": "Sprawdź czy dependencies są zainstalowane poprawnie i aplikacja NestJS startuje bez błędów",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja NotificationsGateway z podstawowymi eventami",
            "description": "Stworzenie głównego Gateway z eventami user-connected, user-disconnected, new-comment, new-rating, live-update",
            "dependencies": [
              1
            ],
            "details": "Stwórz notifications.gateway.ts z dekoratorem @WebSocketGateway(). Zaimplementuj handleConnection, handleDisconnect i eventy: @SubscribeMessage('user-connected'), @SubscribeMessage('user-disconnected'). Dodaj emit methods dla new-comment, new-rating, live-update.",
            "status": "pending",
            "testStrategy": "Sprawdź czy WebSocket connection się nawiązuje, eventy są odbierane i emitowane poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja JWT authentication dla WebSocket connections",
            "description": "Dodanie weryfikacji JWT tokenów przy nawiązywaniu połączeń WebSocket z użytkownikami",
            "dependencies": [
              2
            ],
            "details": "Stwórz WsJwtGuard extends CanActivate. Zaimplementuj extractTokenFromSocket() method. Dodaj @UseGuards(WsJwtGuard) do Gateway. Obsłuż błędy authentication i disconnect unauthorized users. Dekoduj user data z JWT tokenu.",
            "status": "pending",
            "testStrategy": "Sprawdź czy unauthorized users są odrzucani, valid JWT tokens pozwalają na connection, user data jest dostępne w socket context",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja rooms system dla różnych content pages",
            "description": "Stworzenie systemu pokoi umożliwiającego izolację notyfikacji dla konkretnych artykułów, stron wiki itp.",
            "dependencies": [
              3
            ],
            "details": "Dodaj joinRoom(contentType, contentId) i leaveRoom() methods w Gateway. Implementuj room naming convention: `${contentType}:${contentId}`. Dodaj automatic room joining przy user-connected event. Zaimplementuj broadcast methods dla specific rooms.",
            "status": "pending",
            "testStrategy": "Sprawdź czy users dołączają do odpowiednich rooms, notifications są wysyłane tylko do users w danym room, room isolation działa poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integracja real-time notifications z istniejącymi serwisami",
            "description": "Połączenie NotificationsGateway z CommentsService i RatingsService dla automatycznego wysyłania live updates",
            "dependencies": [
              4
            ],
            "details": "Dodaj @Injectable() NotificationsService z methods: notifyNewComment(), notifyNewRating(), notifyLiveUpdate(). Wstrzyknij do CommentsService i RatingsService. Wywołuj notifications po utworzeniu comment/rating. Dodaj payload z user info i content data.",
            "status": "pending",
            "testStrategy": "Sprawdź czy nowe komentarze i oceny trigger real-time notifications, payload zawiera poprawne dane, wszystcy users w room otrzymują powiadomienia",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już dobrze podzielone na 5 subtasków obejmujących WebSocket setup, authentication, rooms i monitoring."
      },
      {
        "id": "17",
        "title": "Integracja MeiliSearch dla wyszukiwania",
        "description": "Konfiguracja i implementacja zaawansowanego wyszukiwania full-text",
        "details": "Zainstaluj meilisearch client. Stwórz SearchModule z SearchService. Implementuj indexowanie wszystkich content types, faceted search, autocomplete, typo tolerance. Dodaj endpoint GET /search z parametrami: q, filters, facets, limit, offset. Implementuj background indexing z BullMQ.",
        "testStrategy": "Sprawdź czy wyszukiwanie zwraca wyniki < 50ms, autocomplete działa, faceted filters działają, typo tolerance działa",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalacja i konfiguracja MeiliSearch client",
            "description": "Zainstalowanie pakietu meilisearch dla Node.js i skonfigurowanie podstawowego połączenia",
            "dependencies": [],
            "details": "Wykonaj `npm install meilisearch` w backend/. Stwórz plik config/meilisearch.config.ts z konfiguracją host, API key, timeout. Dodaj zmienne środowiskowe MEILISEARCH_HOST i MEILISEARCH_API_KEY do .env. Stwórz connection service z podstawowymi metodami ping i health check.",
            "status": "pending",
            "testStrategy": "Sprawdź czy połączenie z MeiliSearch się nawiązuje, ping zwraca odpowiedź, health check pokazuje status OK",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Utworzenie SearchModule i SearchService",
            "description": "Implementacja modułu wyszukiwania z podstawowymi serwisami i konfiguracją",
            "dependencies": [
              1
            ],
            "details": "Stwórz SearchModule w src/search/ z SearchService. Zaimplementuj metody: createIndex, deleteIndex, addDocuments, updateDocuments, deleteDocuments. Skonfiguruj indexy dla każdego content type (articles, blog, wiki, gallery, stories). Dodaj TypeScript interface dla search documents.",
            "status": "pending",
            "testStrategy": "Sprawdź czy SearchModule się ładuje, indexy się tworzą poprawnie, podstawowe operacje CRUD na dokumentach działają",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja indexowania wszystkich content types",
            "description": "Stworzenie systemu automatycznego indexowania artykułów, blogów, wiki, galerii i historii",
            "dependencies": [
              2
            ],
            "details": "Dodaj metody indexowania w SearchService dla każdego typu contentu. Stwórz mappers konwertujące entity na search documents. Implementuj bulk indexing dla istniejących danych. Dodaj hooks w service layer do auto-indexowania przy create/update/delete. Skonfiguruj index settings: searchable attributes, filterable attributes, sortable attributes.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie content types są indexowane, bulk indexing działa, auto-indexing przy CRUD operacjach działa poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja zaawansowanych funkcji wyszukiwania",
            "description": "Dodanie faceted search, autocomplete, typo tolerance i innych zaawansowanych funkcji",
            "dependencies": [
              3
            ],
            "details": "Implementuj faceted search z filters dla categories, tags, authors, dates. Dodaj autocomplete suggestions endpoint. Skonfiguruj typo tolerance settings w MeiliSearch. Implementuj highlighting wyników wyszukiwania. Dodaj sorting options (relevance, date, popularity). Stwórz search analytics tracking.",
            "status": "pending",
            "testStrategy": "Sprawdź czy faceted filters działają poprawnie, autocomplete zwraca sugestie < 100ms, typo tolerance poprawia wyniki, highlighting działa",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Utworzenie search API endpoint i background indexing",
            "description": "Implementacja REST API dla wyszukiwania i systemu background indexing z BullMQ",
            "dependencies": [
              4
            ],
            "details": "Stwórz SearchController z endpointem GET /api/search. Dodaj parametry: q (query), filters, facets, limit, offset, sort. Implementuj pagination i response formatting. Zainstaluj @nestjs/bull i skonfiguruj queue dla background indexing. Stwórz job processor dla bulk re-indexing i scheduled updates. Dodaj rate limiting dla search endpoint.",
            "status": "pending",
            "testStrategy": "Sprawdź czy search endpoint zwraca wyniki < 50ms, pagination działa, background jobs wykonują się poprawnie, rate limiting blokuje spam",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już bardzo dobry podział na 5 subtasków pokrywających indexowanie, search API i background processing."
      },
      {
        "id": "18",
        "title": "Implementacja BullMQ dla background jobs",
        "description": "Konfiguracja systemu kolejek dla zadań w tle",
        "details": "Zainstaluj @nestjs/bull, bull. Stwórz QueuesModule z processors dla: email-queue, image-processing-queue, search-indexing-queue. Implementuj retry logic, job scheduling, progress tracking. Dodaj dashboard monitoring dla queues.",
        "testStrategy": "Sprawdź czy jobs są dodawane do kolejek, processors wykonują zadania, retry logic działa, dashboard pokazuje status jobs",
        "priority": "medium",
        "dependencies": [
          "17"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalacja i konfiguracja BullMQ dependencies",
            "description": "Zainstalowanie wymaganych pakietów dla BullMQ oraz podstawowa konfiguracja",
            "dependencies": [],
            "details": "Zainstaluj @nestjs/bull, bull, @types/bull. Skonfiguruj Redis connection w app.module.ts. Dodaj BullModule.forRoot() z konfiguracją Redis URL, retry settings i basic options.",
            "status": "pending",
            "testStrategy": "Sprawdź czy pakiety są zainstalowane, Redis connection działa, BullModule jest poprawnie zarejestrowany",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Stworzenie QueuesModule z definicjami kolejek",
            "description": "Utworzenie modułu do zarządzania kolejkami z konfiguracją trzech głównych kolejek",
            "dependencies": [
              1
            ],
            "details": "Stwórz QueuesModule z BullModule.registerQueue() dla email-queue, image-processing-queue, search-indexing-queue. Skonfiguruj default job options, delays, attempts. Dodaj QueueService do zarządzania job lifecycle.",
            "status": "pending",
            "testStrategy": "Sprawdź czy kolejki są zarejestrowane, można dodawać jobs, basic queue operations działają",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja procesorów dla każdej kolejki",
            "description": "Stworzenie procesorów odpowiedzialnych za przetwarzanie jobów w poszczególnych kolejkach",
            "dependencies": [
              2
            ],
            "details": "Stwórz EmailProcessor z @Process('email-queue') dla email sending, ImageProcessor dla image processing, SearchProcessor dla indexing. Implementuj error handling, job completion status, progress reporting dla każdego procesora.",
            "status": "pending",
            "testStrategy": "Sprawdź czy procesory są rejestrowane, przetwarzają jobs, error handling działa, progress jest reportowany",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Konfiguracja retry logic i job scheduling",
            "description": "Implementacja zaawansowanej logiki ponownych prób oraz planowania zadań",
            "dependencies": [
              3
            ],
            "details": "Skonfiguruj retry attempts, backoff strategies (exponential, fixed), failed job handling. Implementuj job scheduling z cron patterns, delayed jobs. Dodaj job priorities, lifespan management.",
            "status": "pending",
            "testStrategy": "Sprawdź czy failed jobs są ponawiane, scheduling działa zgodnie z cron, priorities są respektowane",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja dashboard monitoringu kolejek",
            "description": "Stworzenie interfejsu do monitorowania statusu kolejek i zarządzania jobami",
            "dependencies": [
              4
            ],
            "details": "Zainstaluj bull-board lub arena dashboard. Skonfiguruj monitoring endpoint /admin/queues z authentication. Dodaj metryki: active jobs, completed, failed, delayed. Implementuj job retry, clean operations z UI.",
            "status": "pending",
            "testStrategy": "Sprawdź czy dashboard jest dostępny, pokazuje aktualne statystyki, operations (retry, clean) działają przez UI",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już właściwie podzielone na 5 subtasków obejmujących queue setup, procesory i monitoring dashboard."
      },
      {
        "id": "19",
        "title": "Implementacja systemu email z MailerSend",
        "description": "Konfiguracja wysyłania emaili z templates i queue system",
        "details": "Zainstaluj @nestjs/mailer, nodemailer. Skonfiguruj MailerSend jako transport. Stwórz EmailModule z EmailService. Implementuj templates: welcome, password-reset, comment-notification, newsletter. Integruj z BullMQ dla reliable delivery.",
        "testStrategy": "Sprawdź czy welcome email wysyła się po rejestracji, password reset działa, notification emails wysyłają się, templates renderują się poprawnie",
        "priority": "medium",
        "dependencies": [
          "18"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalacja i konfiguracja podstawowych zależności email",
            "description": "Zainstaluj @nestjs/mailer, nodemailer i skonfiguruj MailerSend jako transport dla aplikacji",
            "dependencies": [],
            "details": "Zainstaluj pakiety: npm install @nestjs/mailer nodemailer @mailersend/mailersend. Skonfiguruj MailerSend API key w zmiennych środowiskowych. Stwórz konfigurację MailerSend transportu w pliku konfiguracyjnym z odpowiednimi ustawieniami SMTP/API.",
            "status": "pending",
            "testStrategy": "Sprawdź czy pakiety są poprawnie zainstalowane, konfiguracja transportu łączy się z MailerSend API, test connection kończy się sukcesem",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Utworzenie EmailModule i EmailService",
            "description": "Stwórz moduł email z serwisem obsługującym wysyłanie wiadomości",
            "dependencies": [
              1
            ],
            "details": "Stwórz EmailModule z importem MailerModule. Implementuj EmailService z metodami: sendWelcomeEmail(), sendPasswordResetEmail(), sendCommentNotification(), sendNewsletter(). Dodaj error handling i logging dla każdej metody wysyłania.",
            "status": "pending",
            "testStrategy": "Sprawdź czy EmailService można wstrzyknąć do innych modułów, metody wysyłania zwracają odpowiednie statusy, error handling działa poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja szablonów email (templates)",
            "description": "Stwórz szablony HTML dla różnych typów wiadomości email",
            "dependencies": [
              2
            ],
            "details": "Stwórz folder templates/ z plikami: welcome.hbs, password-reset.hbs, comment-notification.hbs, newsletter.hbs. Użyj Handlebars jako template engine. Dodaj responsive design, zmienne dynamiczne (username, resetLink, etc.), inline CSS dla kompatybilności z klientami email.",
            "status": "pending",
            "testStrategy": "Sprawdź czy templates renderują się poprawnie z danymi testowymi, responsive design działa na różnych klientach email, zmienne są poprawnie podstawiane",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integracja z BullMQ dla kolejkowania emaili",
            "description": "Skonfiguruj system kolejek dla niezawodnego dostarczania emaili",
            "dependencies": [
              2
            ],
            "details": "Zainstaluj @nestjs/bull, bull. Stwórz EmailQueueModule z konfiguracją Redis. Implementuj EmailProcessor do obsługi zadań z kolejki. Dodaj retry logic, dead letter queue, monitoring kolejki. Zmodyfikuj EmailService aby używał kolejki zamiast bezpośredniego wysyłania.",
            "status": "pending",
            "testStrategy": "Sprawdź czy emaile są dodawane do kolejki, processor przetwarza zadania, retry działa przy błędach, dead letter queue przechowuje nieudane zadania",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integracja systemu email z modułami aplikacji",
            "description": "Podłącz wysyłanie emaili do odpowiednich zdarzeń w aplikacji",
            "dependencies": [
              3,
              4
            ],
            "details": "Zintegruj EmailService z AuthModule (welcome email po rejestracji, reset hasła), CommentsModule (powiadomienia o komentarzach), UsersModule (newsletter). Dodaj event listeners lub bezpośrednie wywołania w odpowiednich miejscach kodu. Skonfiguruj zmienne środowiskowe dla włączania/wyłączania emaili.",
            "status": "pending",
            "testStrategy": "Sprawdź czy welcome email wysyła się po rejestracji, password reset email działa, powiadomienia o komentarzach są wysyłane, newsletter można wysłać do użytkowników",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już odpowiedni podział na 5 subtasków pokrywających email setup, templates i integrację z BullMQ."
      },
      {
        "id": "20",
        "title": "Implementacja content workflow (draft/published/scheduled)",
        "description": "System zarządzania statusem treści i publikacji zaplanowanej",
        "details": "Dodaj pole status do wszystkich content entities: draft, pending-review, scheduled, published, archived. Implementuj scheduled publishing z BullMQ cron jobs. Dodaj version history, auto-save drafts co 30s. Implementuj preview mode dla draft content.",
        "testStrategy": "Sprawdź czy draft content nie jest publiczne, scheduled content publikuje się automatycznie, auto-save działa, version history zapisuje się",
        "priority": "medium",
        "dependencies": [
          "19"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Rozszerzenie schema bazy danych o status workflow",
            "description": "Dodanie pola status do wszystkich content entities z enum: draft, pending-review, scheduled, published, archived",
            "dependencies": [],
            "details": "Stwórz migration dodający pole 'status' typu enum do tabel: articles, blog_posts, wiki_pages, gallery_items, stories. Dodaj pole 'scheduledPublishAt' typu timestamp. Zaktualizuj wszystkie entity klasy w TypeORM z nowymi polami. Ustaw domyślny status na 'draft' dla nowych rekordów.",
            "status": "pending",
            "testStrategy": "Sprawdź czy migracja wykonuje się bez błędów, nowe pola są dodane do wszystkich tabel, domyślne wartości są ustawione",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja scheduled publishing z BullMQ",
            "description": "Konfiguracja systemu kolejek do automatycznej publikacji zaplanowanej treści",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj BullMQ i Redis. Stwórz PublishingQueue z job 'publishScheduledContent'. Implementuj PublishingProcessor który zmienia status z 'scheduled' na 'published'. Skonfiguruj cron job sprawdzający co minutę scheduled content. Dodaj endpoint do planowania publikacji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy scheduled content publikuje się automatycznie w określonym czasie, queue worker przetwarza joby poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja version history system",
            "description": "System przechowywania historii wersji dla content entities",
            "dependencies": [
              1
            ],
            "details": "Stwórz ContentVersionEntity z polami: contentId, contentType, version, data, createdAt, author. Implementuj ContentVersionService z metodami saveVersion, getVersions, restoreVersion. Dodaj automatyczne zapisywanie wersji przy każdej zmianie content. Stwórz endpoint do przeglądania historii wersji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy każda zmiana content tworzy nową wersję, można przywrócić poprzednią wersję, historia wersji jest poprawnie wyświetlana",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja auto-save drafts",
            "description": "Automatyczny zapis roboczych wersji co 30 sekund podczas edycji",
            "dependencies": [
              3
            ],
            "details": "Stwórz AutoSaveService z metodą saveDraft. Implementuj frontend timer który wywołuje auto-save co 30s. Dodaj endpoint POST /content/:type/:id/autosave. Użyj debouncing dla optymalizacji. Przechowuj drafts w osobnej tabeli lub jako specjalny typ version.",
            "status": "pending",
            "testStrategy": "Sprawdź czy auto-save uruchamia się co 30s podczas edycji, drafts są zapisywane poprawnie, nie ma konfliktów z manual save",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja preview mode dla draft content",
            "description": "Możliwość podglądu nieopublikowanej treści przez autoryzowanych użytkowników",
            "dependencies": [
              1,
              4
            ],
            "details": "Dodaj query parameter ?preview=true do content endpoints. Zmodyfikuj content services aby zwracały draft/scheduled content z preview flag. Implementuj PreviewGuard sprawdzający uprawnienia. Stwórz specjalne preview URLs z tokenami. Dodaj preview banner w UI.",
            "status": "pending",
            "testStrategy": "Sprawdź czy draft content jest dostępne z preview URLs, preview nie jest dostępne bez autoryzacji, preview banner wyświetla się poprawnie",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już bardzo dobrze podzielone na 5 subtasków obejmujących status system, scheduling, version history i preview."
      },
      {
        "id": "21",
        "title": "Implementacja Analytics i tracking",
        "description": "System śledzenia wyświetleń i zachowań użytkowników",
        "details": "Stwórz AnalyticsModule z AnalyticsService. Implementuj privacy-friendly tracking: page views, time on page, popular content, user paths. Dodaj endpoints: GET /analytics/dashboard, GET /analytics/popular, GET /analytics/trends. Użyj Redis do aggregacji danych.",
        "testStrategy": "Sprawdź czy page views są trackowane, popular content aktualizuje się, dashboard analytics wyświetla dane, privacy jest zachowana",
        "priority": "low",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie AnalyticsModule z AnalyticsService",
            "description": "Implementacja podstawowego modułu analytics z serwisem do śledzenia działań użytkowników",
            "dependencies": [],
            "details": "Stwórz AnalyticsModule w backend/src/modules/analytics/. Implementuj AnalyticsService z metodami do trackowania page views, time on page, user paths. Skonfiguruj połączenie z Redis do przechowywania danych analitycznych. Dodaj podstawowe interfejsy i DTOs dla danych analytics.",
            "status": "pending",
            "testStrategy": "Unit testy dla AnalyticsService, sprawdzenie czy tracking events są prawidłowo zapisywane do Redis",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja privacy-friendly tracking systemu",
            "description": "System śledzenia zachowań użytkowników z zachowaniem prywatności",
            "dependencies": [
              1
            ],
            "details": "Implementuj tracking page views, czasu spędzonego na stronie, ścieżek użytkowników bez zbierania danych osobowych. Użyj hashy lub anonymizacji IP. Dodaj mechanizm opt-out dla użytkowników. Implementuj tracking middleware dla frontend.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy dane są anonimizowane, tracking działa bez cookies osobowych, opt-out funkcjonuje",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja agregacji danych w Redis",
            "description": "System agregacji i cache'owania danych analitycznych w Redis",
            "dependencies": [
              1,
              2
            ],
            "details": "Skonfiguruj Redis do agregacji danych analytics w czasie rzeczywistym. Implementuj daily/weekly/monthly aggregates dla popular content, trends, user behavior patterns. Dodaj TTL dla starych danych, mechanizmy czyszczenia cache.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy agregacja działa poprawnie, dane są cache'owane w Redis, TTL usuwa stare dane",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Stworzenie analytics API endpoints",
            "description": "REST API endpoints do pobierania danych analitycznych",
            "dependencies": [
              3
            ],
            "details": "Implementuj AnalyticsController z endpointami: GET /analytics/dashboard (ogólne statystyki), GET /analytics/popular (popularna treść), GET /analytics/trends (trendy w czasie). Dodaj autoryzację admin, paginację, filtering po datach.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy endpoints zwracają poprawne dane, autoryzacja admin działa, paginacja i filtering funkcjonują",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja analytics dashboard w frontend",
            "description": "Panel administratora z wizualizacją danych analitycznych",
            "dependencies": [
              4
            ],
            "details": "Stwórz komponenty React dla analytics dashboard w frontend/app/dashboard/analytics/. Dodaj wykresy (Chart.js/Recharts), tabele z popularnymi treściami, metryki czasu rzeczywistego. Implementuj responsive design z Tailwind CSS.",
            "status": "pending",
            "testStrategy": "Sprawdzenie czy dashboard ładuje dane z API, wykresy wyświetlają się poprawnie, interface jest responsive",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już odpowiedni podział na 5 subtasków pokrywających tracking, agregację i privacy compliance."
      },
      {
        "id": "22",
        "title": "Implementacja security middleware",
        "description": "Konfiguracja zabezpieczeń - rate limiting, security headers, validation",
        "details": "Zainstaluj @nestjs/throttler, helmet. Skonfiguruj rate limiting per IP/user, security headers (CSP, HSTS, X-Frame-Options). Implementuj input sanitization, CORS configuration. Dodaj audit logging dla admin actions.",
        "testStrategy": "Sprawdź czy rate limiting blokuje spam requests, security headers są ustawione, CORS działa poprawnie, audit logs zapisują admin actions",
        "priority": "high",
        "dependencies": [
          "21"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instalacja i konfiguracja @nestjs/throttler dla rate limiting",
            "description": "Zainstaluj i skonfiguruj @nestjs/throttler do implementacji rate limiting per IP i per użytkownik",
            "dependencies": [],
            "details": "Zainstaluj @nestjs/throttler npm package. Skonfiguruj ThrottlerModule w app.module.ts z limitami requests per minute per IP. Dodaj ThrottlerGuard do kontrolerów. Implementuj custom rate limiting per user ID dla zalogowanych użytkowników. Skonfiguruj różne limity dla różnych endpointów (np. login endpoints mają niższe limity).",
            "status": "pending",
            "testStrategy": "Napisz testy sprawdzające czy rate limiting blokuje requests po przekroczeniu limitu, czy różni użytkownicy mają osobne liczniki, czy custom limity per endpoint działają poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja helmet dla security headers",
            "description": "Konfiguracja helmet middleware do ustawiania security headers w HTTP responses",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj helmet package. Skonfiguruj helmet middleware w main.ts z security headers: Content Security Policy (CSP), HTTP Strict Transport Security (HSTS), X-Frame-Options, X-Content-Type-Options, Referrer-Policy. Dostosuj CSP policy do potrzeb aplikacji (dozwolone domeny dla scripts, styles, images). Skonfiguruj HSTS z odpowiednim max-age.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie security headers są obecne w HTTP responses, czy CSP policy nie blokuje zasobów aplikacji, czy HSTS header ma właściwe wartości",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Konfiguracja CORS i input sanitization",
            "description": "Implementacja CORS configuration i input sanitization dla zabezpieczenia przed XSS",
            "dependencies": [
              2
            ],
            "details": "Skonfiguruj CORS w main.ts z whitelist dozwolonych origins (frontend URLs). Dodaj credentials: true dla cross-origin cookies. Zainstaluj class-sanitizer lub podobne narzędzie. Implementuj custom pipes do sanitization input danych w DTOs. Dodaj whitelist dla HTML content w rich text editorach. Skonfiguruj validation pipes z transform: true.",
            "status": "pending",
            "testStrategy": "Sprawdź czy CORS blokuje requests z niedozwolonych origins, czy dozwala z whitelisted domains, czy input sanitization usuwa potencjalnie niebezpieczne znaki z form inputs",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja audit logging dla admin actions",
            "description": "Stworzenie systemu audit logging do śledzenia wszystkich działań administratorów",
            "dependencies": [
              3
            ],
            "details": "Stwórz AuditLog entity z polami: userId, action, resource, resourceId, oldValues, newValues, ipAddress, userAgent, timestamp. Implementuj AuditLogService z metodami do zapisywania action logs. Stwórz AuditLogInterceptor do automatycznego logowania CRUD operations w admin endpoints. Dodaj manual logging dla krytycznych actions (user role changes, system settings). Skonfiguruj log retention policy.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie admin actions są logowane, czy audit logs zawierają kompletne informacje (user, action, timestamp, changes), czy interceptor automatycznie loguje CRUD operations",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integracja i testowanie kompletnego security middleware",
            "description": "Połączenie wszystkich security komponentów i comprehensive testing",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Zintegruj wszystkie security middleware w logicznej kolejności w main.ts. Skonfiguruj error handling dla security violations. Dodaj security-specific environment variables do .env. Implementuj health check endpoint z security status. Stwórz comprehensive security tests sprawdzające interakcje między różnymi middleware. Dodaj dokumentację security configuration.",
            "status": "pending",
            "testStrategy": "Przeprowadź end-to-end security testing sprawdzając rate limiting + CORS + headers, przetestuj różne attack vectors (XSS, CSRF, rate limiting bypass), sprawdź czy audit logs zapisują się podczas security violations",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już dobrze podzielone na 5 subtasków obejmujących rate limiting, security headers i audit logging."
      },
      {
        "id": "23",
        "title": "Swagger API documentation",
        "description": "Pełna dokumentacja API z interactive docs",
        "details": "Skonfiguruj @nestjs/swagger. Dodaj decoratory @ApiOperation, @ApiResponse, @ApiProperty do wszystkich endpoints i DTOs. Implementuj versioning (/api/v1), authentication dla Swagger. Dodaj example responses i error codes.",
        "testStrategy": "Sprawdź czy /api/docs wyświetla kompletną dokumentację, wszystkie endpoints są udokumentowane, examples działają, authentication w Swagger działa",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Konfiguracja @nestjs/swagger w projekcie",
            "description": "Zainstalowanie i podstawowa konfiguracja pakietu @nestjs/swagger z utworzeniem dokumentu Swagger",
            "dependencies": [],
            "details": "Zainstaluj @nestjs/swagger i swagger-ui-express. W main.ts skonfiguruj SwaggerModule.createDocument() z podstawowymi opcjami. Ustaw endpoint /api/docs dla dokumentacji. Dodaj tytuł, opis, wersję API.",
            "status": "pending",
            "testStrategy": "Sprawdź czy endpoint /api/docs wyświetla podstawowy interfejs Swagger UI",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Dodanie dekoratorów do wszystkich kontrolerów",
            "description": "Implementacja @ApiOperation i @ApiResponse dla wszystkich endpoints w kontrolerach",
            "dependencies": [
              1
            ],
            "details": "Dodaj @ApiOperation z opisem do każdego endpoint. Implementuj @ApiResponse dla success (200/201) i error responses (400, 401, 404, 500). Użyj @ApiTags do grupowania endpoints po modułach.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie endpoints mają opisy i response codes w dokumentacji Swagger",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Dokumentacja DTOs z @ApiProperty",
            "description": "Dodanie dekoratorów @ApiProperty do wszystkich DTOs z przykładami i walidacją",
            "dependencies": [
              2
            ],
            "details": "Dodaj @ApiProperty do każdego pola w CreateDto, UpdateDto. Incluej example values, description, type, format. Dodaj @ApiPropertyOptional dla opcjonalnych pól. Dokumentuj validation rules.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie DTOs mają pełną dokumentację pól z przykładami w Swagger UI",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja versioning API (/api/v1)",
            "description": "Konfiguracja versioning dla API z prefiksem /api/v1 dla wszystkich endpoints",
            "dependencies": [
              3
            ],
            "details": "W main.ts ustaw globalPrefix '/api/v1'. Zaktualizuj wszystkie kontrolery żeby działały pod /api/v1/*. Skonfiguruj Swagger żeby pokazywał właściwe ścieżki z wersją.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie API endpoints działają pod /api/v1/ i dokumentacja pokazuje właściwe ścieżki",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Konfiguracja authentication w Swagger UI",
            "description": "Dodanie JWT Bearer authentication do dokumentacji Swagger z możliwością testowania",
            "dependencies": [
              4
            ],
            "details": "Skonfiguruj @ApiBearerAuth() dla protected endpoints. W SwaggerModule dodaj security definition dla JWT Bearer. Implementuj 'Authorize' button w Swagger UI. Dodaj przykłady error responses dla unauthorized (401).",
            "status": "pending",
            "testStrategy": "Sprawdź czy można się zalogować w Swagger UI przez Authorize button i testować protected endpoints",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już właściwy podział na 5 subtasków pokrywających Swagger setup, dekoratory i authentication integration."
      },
      {
        "id": "24",
        "title": "Seed data i przykładowe dane",
        "description": "Skrypt do generowania realistycznych przykładowych danych",
        "details": "Stwórz seed script w prisma/seed.ts. Wygeneruj: 20 artykułów, 15 blog postów, 10 stron wiki, 25 zdjęć, 10 opowiadań, 5 autorów, 100+ komentarzy, kategorie, tagi, oceny. Użyj faker.js dla realistycznych danych. Dodaj default admin account.",
        "testStrategy": "Sprawdź czy `npx prisma db seed` generuje dane, wszystkie content types mają przykłady, relacje są poprawne, można się zalogować na admin",
        "priority": "medium",
        "dependencies": [
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Konfiguracja faker.js i podstawowej struktury seed",
            "description": "Instalacja faker.js i stworzenie podstawowej struktury pliku seed.ts z importami i konfiguracją",
            "dependencies": [],
            "details": "Zainstaluj faker.js jako devDependency. Stwórz plik prisma/seed.ts z importami Prisma Client i faker. Skonfiguruj podstawową strukturę funkcji main() i async/await handling. Dodaj seed script do package.json.",
            "status": "pending",
            "testStrategy": "Sprawdź czy faker.js jest zainstalowany, seed.ts kompiluje się bez błędów, npm run seed uruchamia się",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Generowanie danych użytkowników i autorów",
            "description": "Stworzenie funkcji do generowania użytkowników, w tym domyślnego konta admin i 5 autorów",
            "dependencies": [
              1
            ],
            "details": "Wygeneruj domyślne konto admin (email: admin@portal.com, hasło: admin123). Stwórz 5 autorów z realistycznymi danymi używając faker.js: name, bio, email, profileImage. Użyj bcrypt do hashowania haseł.",
            "status": "pending",
            "testStrategy": "Sprawdź czy admin account jest tworzony, 5 autorów ma kompletne dane, hasła są hashowane",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Generowanie kategorii, tagów i podstawowych metadanych",
            "description": "Stworzenie kategorii i tagów dla wszystkich typów treści",
            "dependencies": [
              2
            ],
            "details": "Wygeneruj 10-15 kategorii (Tech, Lifestyle, Travel, Food, etc.) i 25-30 tagów. Stwórz funkcje pomocnicze do losowego wyboru kategorii/tagów dla content items. Dodaj timestamps i metadata.",
            "status": "pending",
            "testStrategy": "Sprawdź czy kategorie i tagi są tworzone, funkcje pomocnicze działają poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Generowanie treści - artykuły, blog, wiki, galeria, opowiadania",
            "description": "Stworzenie wszystkich typów treści z realistycznymi danymi i przypisanymi autorami",
            "dependencies": [
              3
            ],
            "details": "Wygeneruj: 20 artykułów, 15 postów blogowych, 10 stron wiki (z hierarchią parent-child), 25 elementów galerii, 10 opowiadań. Każdy element ma tytuł, treść (faker.lorem), autora, kategorie, tagi, daty publikacji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie typy treści są generowane, mają przypisanych autorów, kategorie i tagi",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Generowanie komentarzy, ocen i finalizacja",
            "description": "Dodanie interakcji użytkowników - komentarzy i ocen do wszystkich treści",
            "dependencies": [
              4
            ],
            "details": "Wygeneruj 100+ komentarzy rozłożonych na wszystkie typy treści. Dodaj komentarze zagnieżdżone (replies). Wygeneruj oceny (1-5 gwiazdek) dla każdej treści. Uruchom seed i sprawdź poprawność danych.",
            "status": "pending",
            "testStrategy": "Sprawdź czy komentarze są przypisane do treści, oceny są w zakresie 1-5, npx prisma db seed wykonuje się bez błędów",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już odpowiednio podzielone na 5 subtasków obejmujących seed setup, generowanie różnych typów danych i relacji."
      },
      {
        "id": "25",
        "title": "Konfiguracja Next.js frontend z podstawowymi komponentami",
        "description": "Setup Next.js z TailwindCSS, basic layout i navigation",
        "details": "Skonfiguruj src/app layout z navigation, footer, sidebar. Zainstaluj shadcn/ui components. Stwórz podstawowe komponenty: Header, Navigation, Footer, LoadingSpinner, ErrorBoundary. Skonfiguruj TanStack Query i Zustand store.",
        "testStrategy": "Sprawdź czy layout renderuje się poprawnie, navigation działa, responsive design działa na mobile, components ładują się bez błędów",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Inicjalizacja Next.js 14 z App Router",
            "description": "Stworzenie nowego projektu Next.js 14 z App Router i podstawową konfiguracją",
            "dependencies": [],
            "details": "Wykonaj `npx create-next-app@latest frontend --typescript --tailwind --eslint --app --src-dir --import-alias \"@/*\"` w folderze głównym. Skonfiguruj next.config.js z podstawowymi ustawieniami. Skonfiguruj TypeScript i ESLint. Dodaj podstawowe foldery w src/: app, components, lib, types, hooks.",
            "status": "done",
            "testStrategy": "Sprawdź czy `npm run dev` uruchamia aplikację na localhost:3000, TypeScript kompiluje się bez błędów, TailwindCSS styles ładują się poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Instalacja i konfiguracja shadcn/ui",
            "description": "Dodanie biblioteki shadcn/ui z podstawowymi komponentami UI",
            "dependencies": [
              1
            ],
            "details": "Wykonaj `npx shadcn-ui@latest init` w folderze frontend. Skonfiguruj components.json z odpowiednimi ścieżkami. Zainstaluj podstawowe komponenty: `npx shadcn-ui@latest add button card input dialog toast navigation-menu`. Skonfiguruj globals.css z CSS variables dla theme.",
            "status": "done",
            "testStrategy": "Sprawdź czy shadcn/ui komponenty importują się bez błędów, styles theme działają poprawnie, komponenty renderują się z odpowiednimi stylami",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie podstawowych komponentów layout",
            "description": "Implementacja Header, Navigation, Footer i podstawowych komponentów UI",
            "dependencies": [
              2
            ],
            "details": "Stwórz komponenty w src/components/: Header.tsx (logo, user menu, search), Navigation.tsx (main navigation menu), Footer.tsx (links, copyright), LoadingSpinner.tsx, ErrorBoundary.tsx. Wszystkie komponenty z TypeScript interfaces i responsive design. Użyj shadcn/ui komponentów jako baza.",
            "status": "done",
            "testStrategy": "Sprawdź czy wszystkie komponenty renderują się bez błędów, responsive design działa na mobile/desktop, TypeScript types są poprawne",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Konfiguracja App Router layout",
            "description": "Implementacja głównego layout w src/app z navigation i routing",
            "dependencies": [
              3
            ],
            "details": "Skonfiguruj src/app/layout.tsx z Header, Navigation, main content area i Footer. Stwórz page.tsx jako homepage. Dodaj loading.tsx, error.tsx, not-found.tsx templates. Skonfiguruj metadata i viewport settings. Dodaj podstawowe routing dla /blog, /articles, /wiki, /gallery, /stories.",
            "status": "done",
            "testStrategy": "Sprawdź czy layout renderuje się poprawnie na wszystkich stronach, navigation działa, loading states działają, error boundaries catchują błędy",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Konfiguracja TanStack Query i Zustand store",
            "description": "Setup state management i data fetching dla aplikacji",
            "dependencies": [
              4
            ],
            "details": "Zainstaluj @tanstack/react-query i zustand. Stwórz QueryClient provider w layout.tsx. Stwórz Zustand stores w src/lib/store/: authStore.ts (user state), uiStore.ts (sidebar, modals). Stwórz query hooks w src/hooks/ dla API calls. Skonfiguruj devtools dla development.",
            "status": "done",
            "testStrategy": "Sprawdź czy TanStack Query devtools działają, Zustand store zapisuje state poprawnie, query hooks wykonują się bez błędów, devtools pokazują state changes",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już dobrą strukturę 5 subtasków pokrywającą Next.js setup, shadcn/ui, layout i state management."
      },
      {
        "id": "26",
        "title": "Implementacja autentykacji frontend",
        "description": "Login/register forms z JWT handling i protected routes",
        "details": "Stwórz strony /login, /register z React Hook Form + Zod validation. Implementuj JWT storage w localStorage, automatic token refresh, protected route wrapper. Stwórz AuthContext/Zustand store dla user state. Dodaj logout functionality.",
        "testStrategy": "Sprawdź czy login/register formularze działają, JWT token zapisuje się, protected routes przekierowują do /login, logout czyści token",
        "priority": "high",
        "dependencies": [
          "25"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie formularzy logowania i rejestracji",
            "description": "Implementacja stron /login i /register z React Hook Form i walidacją Zod",
            "dependencies": [],
            "details": "Stwórz komponenty LoginForm i RegisterForm używając React Hook Form. Zaimplementuj schematy walidacji Zod dla email, hasła i potwierdzenia hasła. Dodaj styled components z Tailwind CSS dla responsywnego designu. Implementuj obsługę błędów walidacji i wyświetlanie komunikatów.",
            "status": "done",
            "testStrategy": "Sprawdź czy formularze walidują poprawnie dane wejściowe, wyświetlają błędy walidacji, submitują dane do API",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja JWT storage i automatic refresh",
            "description": "System zarządzania tokenami JWT w localStorage z automatycznym odświeżaniem",
            "dependencies": [
              1
            ],
            "details": "Stwórz utility functions do zapisywania/odczytywania JWT z localStorage. Implementuj automatic token refresh przed wygaśnięciem. Dodaj interceptory axios do automatycznego dodawania Authorization header. Obsłuż scenariusze expired/invalid tokens z przekierowaniem do /login.",
            "status": "done",
            "testStrategy": "Sprawdź czy token zapisuje się w localStorage, automatic refresh działa, expired tokens powodują logout",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie AuthContext/Zustand store",
            "description": "Globalne zarządzanie stanem użytkownika i autentykacji",
            "dependencies": [
              2
            ],
            "details": "Implementuj AuthContext lub Zustand store dla user state (isAuthenticated, user data, loading states). Stwórz custom hooks useAuth, useLogin, useRegister, useLogout. Dodaj persist middleware dla Zustand jeśli używane. Implementuj automatic user data fetch po successful login.",
            "status": "done",
            "testStrategy": "Sprawdź czy auth state persystuje między sesjami, user data ładuje się poprawnie, hooks działają we wszystkich komponentach",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja protected routes wrapper",
            "description": "System ochrony tras wymagających autentykacji",
            "dependencies": [
              3
            ],
            "details": "Stwórz ProtectedRoute component wrapper sprawdzający auth status. Implementuj redirect do /login dla nieautentykowanych użytkowników z return URL. Dodaj loading states podczas weryfikacji tokena. Stwórz RoleGuard dla różnych poziomów dostępu (user/admin).",
            "status": "done",
            "testStrategy": "Sprawdź czy nieautentykowane żądania przekierowują do /login, authenticated users mają dostęp, role-based access działa",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Dodanie funkcjonalności logout",
            "description": "Implementacja bezpiecznego wylogowywania użytkownika",
            "dependencies": [
              4
            ],
            "details": "Stwórz logout function czyszczącą localStorage, auth state i przekierowującą do /login. Dodaj logout button w navigation/header. Implementuj optional server-side token invalidation. Dodaj confirmation dialog dla logout action. Obsłuż cleanup subscriptions/timers.",
            "status": "done",
            "testStrategy": "Sprawdź czy logout czyści wszystkie dane auth, przekierowuje do /login, unieważnia token na serwerze",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już bardzo dobrze podzielone na 5 subtasków obejmujących forms, JWT storage, auth context i protected routes."
      },
      {
        "id": "27",
        "title": "Implementacja landing page",
        "description": "Atrakcyjna strona główna z call-to-action do rejestracji",
        "details": "Stwórz responsive landing page z sections: hero, features, content showcase, call-to-action. Użyj Framer Motion dla animations, Tailwind dla styling. Dodaj SEO meta tags, Open Graph tags. Implementuj mobile-first design.",
        "testStrategy": "Sprawdź czy landing page ładuje się szybko, animations działają, responsive na wszystkich device sizes, SEO tags są poprawne",
        "priority": "medium",
        "dependencies": [
          "26"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie podstawowej struktury landing page",
            "description": "Implementacja podstawowego layoutu strony głównej z sekcjami hero, features, showcase i CTA",
            "dependencies": [],
            "details": "Stwórz komponent LandingPage w Next.js z podstawową strukturą HTML. Zdefiniuj sekcje: HeroSection, FeaturesSection, ContentShowcaseSection, CallToActionSection. Użyj semantic HTML tags (header, main, section). Przygotuj podstawowy routing dla / endpoint.",
            "status": "done",
            "testStrategy": "Sprawdź czy strona renderuje się poprawnie, wszystkie sekcje są widoczne, routing działa",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja responsive design z Tailwind CSS",
            "description": "Stylizacja landing page z mobile-first approach używając Tailwind CSS",
            "dependencies": [
              1
            ],
            "details": "Implementuj responsive grid layout używając Tailwind CSS classes. Zdefiniuj breakpoints dla mobile (sm), tablet (md), desktop (lg). Stwórz utility classes dla spacing, typography, colors. Zapewnij mobile-first design z progressive enhancement dla większych ekranów.",
            "status": "done",
            "testStrategy": "Sprawdź responsywność na różnych rozmiarach ekranu (320px, 768px, 1024px, 1440px)",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Dodanie animacji z Framer Motion",
            "description": "Implementacja smooth animations i transitions dla lepszego user experience",
            "dependencies": [
              2
            ],
            "details": "Zainstaluj framer-motion. Dodaj fade-in animations dla sekcji przy scroll, hover effects dla buttons i cards. Implementuj staggered animations dla list elementów. Stwórz custom motion variants dla consistent animation timing.",
            "status": "done",
            "testStrategy": "Sprawdź czy animacje działają smoothly, nie powodują lag-u, są dostępne na wszystkich urządzeniach",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja sekcji Hero i Features",
            "description": "Stworzenie głównej sekcji hero z CTA oraz sekcji prezentującej funkcjonalności portalu",
            "dependencies": [
              3
            ],
            "details": "HeroSection: headline, subheadline, primary CTA button do rejestracji, hero image/video. FeaturesSection: grid 3-4 features (Articles, Blog, Wiki, Gallery) z ikonami, krótkimi opisami. Dodaj hover effects, responsive images, proper semantic markup.",
            "status": "done",
            "testStrategy": "Sprawdź czy CTA button prowadzi do rejestracji, features są czytelne, images ładują się poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optymalizacja SEO i meta tags",
            "description": "Dodanie SEO meta tags, Open Graph tags i optymalizacja dla wyszukiwarek",
            "dependencies": [
              4
            ],
            "details": "Implementuj Next.js Metadata API. Dodaj title, description, keywords meta tags. Skonfiguruj Open Graph tags (og:title, og:description, og:image, og:url). Dodaj structured data (JSON-LD). Implementuj robots.txt, sitemap.xml. Optymalizuj Core Web Vitals.",
            "status": "done",
            "testStrategy": "Sprawdź meta tags w browser dev tools, przetestuj Open Graph w Facebook/Twitter debugger, zmierz PageSpeed Insights score",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już odpowiedni podział na 5 subtasków pokrywających strukturę, animacje, sekcje i SEO optimization."
      },
      {
        "id": "28",
        "title": "Implementacja stron content (blog, articles, wiki)",
        "description": "Strony listy i szczegółów dla wszystkich typów treści",
        "details": "Stwórz strony: /blog, /blog/[slug], /articles, /articles/[slug], /wiki, /wiki/[slug]. Implementuj pagination, filtering, search bar. Dodaj components: ContentList, ContentDetail, CommentSection, RatingWidget. Integruj z TanStack Query dla data fetching.",
        "testStrategy": "Sprawdź czy wszystkie content pages ładują dane, pagination działa, filtering po kategoriach działa, search zwraca wyniki",
        "priority": "high",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie stron routing dla content types",
            "description": "Implementacja routingu Next.js dla wszystkich typów treści",
            "dependencies": [],
            "details": "Stwórz strony: app/blog/page.tsx (lista), app/blog/[slug]/page.tsx (szczegóły), app/articles/page.tsx, app/articles/[slug]/page.tsx, app/wiki/page.tsx, app/wiki/[slug]/page.tsx. Skonfiguruj dynamic routing, generateMetadata dla SEO, loading states. Użyj App Router Next.js 14.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie routes są dostępne, dynamic params działają, metadata są generowane poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja ContentList component",
            "description": "Komponent do wyświetlania listy treści z pagination i filtering",
            "dependencies": [
              1
            ],
            "details": "Stwórz ContentList component z props: contentType, pagination, filters. Implementuj grid/list view toggle, kategorie filter, tags filter, search input, sort options. Użyj Tailwind CSS dla responsive design. Dodaj skeleton loading states.",
            "status": "pending",
            "testStrategy": "Sprawdź czy komponenty renderują się poprawnie, filtering działa, pagination przechodzi między stronami",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja ContentDetail component",
            "description": "Komponent do wyświetlania szczegółów pojedynczej treści",
            "dependencies": [
              1
            ],
            "details": "Stwórz ContentDetail component wyświetlający tytuł, content, author info, categories, tags, publication date. Dodaj related content suggestions, share buttons, print view. Implementuj breadcrumbs navigation dla wiki hierarchy.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie dane wyświetlają się poprawnie, related content ładuje się, share buttons działają",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integracja TanStack Query dla data fetching",
            "description": "Konfiguracja i implementacja TanStack Query dla wszystkich content API calls",
            "dependencies": [
              2,
              3
            ],
            "details": "Zainstaluj @tanstack/react-query. Stwórz QueryClient config, custom hooks: useArticles, useArticle, useBlogPosts, useBlogPost, useWikiPages, useWikiPage. Implementuj infinite queries dla pagination, optimistic updates, cache invalidation.",
            "status": "pending",
            "testStrategy": "Sprawdź czy queries cachują dane, infinite scroll działa, optimistic updates działają poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja CommentSection i RatingWidget",
            "description": "Interaktywne komponenty dla komentarzy i ocen treści",
            "dependencies": [
              3
            ],
            "details": "Stwórz CommentSection z nested replies, add/edit/delete comments, user avatars. Implementuj RatingWidget z 5-star system, average rating display, user voting. Dodaj authentication guards, optimistic UI updates. Integruj z TanStack Query mutations.",
            "status": "pending",
            "testStrategy": "Sprawdź czy komentarze można dodawać/edytować, oceny zapisują się poprawnie, nested replies działają",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie jest już bardzo dobrze podzielone na 5 subtasków obejmujących routing, komponenty, TanStack Query i interactive features.",
        "updatedAt": "2025-11-06T16:35:17.809Z"
      },
      {
        "id": "29",
        "title": "Implementacja galerii i media viewer",
        "description": "Galeria zdjęć/filmów z lightbox i lazy loading",
        "details": "Stwórz /gallery z grid layout, lazy loading, infinite scroll. Implementuj lightbox/modal dla przeglądania zdjęć. Dodaj filtering po kategoriach, tagach. Integruj z upload functionality (drag & drop). Użyj Next.js Image component dla optymalizacji.",
        "testStrategy": "Sprawdź czy galeria ładuje obrazy lazy loading, lightbox działa, infinite scroll działa, filtering po kategoriach działa",
        "priority": "medium",
        "dependencies": [
          "28"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie struktury strony galerii z grid layout",
            "description": "Implementacja podstawowej strony galerii z responsywnym grid layoutem dla wyświetlania zdjęć i filmów",
            "dependencies": [],
            "details": "Stwórz komponent Gallery w /app/gallery/page.tsx z responsywnym CSS Grid lub Tailwind grid classes. Użyj Next.js Image component dla podstawowej optymalizacji obrazów. Implementuj adaptive grid (1-4 kolumny w zależności od screen size). Przygotuj placeholder strukturę dla media items.",
            "status": "pending",
            "testStrategy": "Sprawdź czy grid jest responsywny na różnych rozmiarach ekranu, obrazy ładują się poprawnie przez Next.js Image",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja lazy loading i infinite scroll",
            "description": "Dodanie lazy loading dla obrazów i infinite scroll dla ładowania kolejnych stron galerii",
            "dependencies": [
              1
            ],
            "details": "Zaimplementuj intersection observer dla lazy loading obrazów. Dodaj infinite scroll używając react-intersection-observer lub własnej implementacji. Stwórz API endpoint dla paginacji galerii (/api/gallery?page=X&limit=Y). Implementuj loading states i skeleton placeholders podczas ładowania.",
            "status": "pending",
            "testStrategy": "Sprawdź czy obrazy ładują się tylko gdy wchodzą w viewport, infinite scroll działa płynnie, loading states wyświetlają się poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja lightbox/modal viewer",
            "description": "Stworzenie lightbox modala do przeglądania zdjęć w pełnym rozmiarze z nawigacją",
            "dependencies": [
              1
            ],
            "details": "Stwórz komponent Lightbox z nawigacją (poprzedni/następny), zoom, close button. Implementuj keyboard navigation (strzałki, escape). Dodaj overlay z blur background. Użyj Portal dla renderowania modala poza DOM tree. Obsłuż touch gestures dla mobile (swipe).",
            "status": "pending",
            "testStrategy": "Sprawdź czy lightbox otwiera się po kliknięciu, nawigacja strzałkami działa, escape zamyka modal, touch gestures działają na mobile",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Dodanie filterowania po kategoriach i tagach",
            "description": "Implementacja systemu filtrowania galerii po kategoriach, tagach i innych kryteriach",
            "dependencies": [
              1
            ],
            "details": "Stwórz komponent FilterBar z dropdown/checkbox dla kategorii i tagów. Implementuj search bar dla wyszukiwania po nazwie/opisie. Dodaj sorting options (data, nazwa, popularity). Użyj URL query parameters dla deep linking filtrów. Implementuj clear filters functionality.",
            "status": "pending",
            "testStrategy": "Sprawdź czy filtering po kategoriach działa, search bar filtruje wyniki, URL zachowuje stan filtrów, clear filters resetuje widok",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integracja z upload functionality (drag & drop)",
            "description": "Implementacja funkcjonalności upload plików z drag & drop interface dla galerii",
            "dependencies": [
              1
            ],
            "details": "Stwórz komponent UploadZone z drag & drop interface. Implementuj file validation (typ, rozmiar, format). Dodaj progress bar dla upload. Stwórz API endpoint /api/gallery/upload z multer middleware. Implementuj preview uploaded files przed zapisaniem. Dodaj batch upload support.",
            "status": "pending",
            "testStrategy": "Sprawdź czy drag & drop działa, file validation blokuje niepoprawne pliki, progress bar pokazuje postęp, uploaded files pojawiają się w galerii",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Zadanie ma już dobrą strukturę 5 subtasków pokrywającą grid layout, lazy loading, lightbox i upload functionality."
      },
      {
        "id": "30",
        "title": "Implementacja systemu komentarzy frontend",
        "description": "Interactive comment section z nested replies i real-time updates",
        "details": "Stwórz CommentSection component z nested comments display, add comment form, reply functionality. Integruj Socket.io dla real-time comment updates. Dodaj moderation controls dla admin/moderator. Implementuj comment pagination.",
        "testStrategy": "Sprawdź czy komentarze wyświetlają się hierarchicznie, można dodawać replies, real-time updates działają, moderacja dla admin działa",
        "priority": "medium",
        "dependencies": [
          "29"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie komponentu CommentList z nested display",
            "description": "Implementacja komponentu wyświetlającego komentarze w strukturze hierarchicznej z zagnieżdżonymi odpowiedziami",
            "dependencies": [],
            "details": "Stwórz komponent CommentList.tsx z obsługą zagnieżdżonych komentarzy. Użyj rekurencyjnego renderowania dla hierarchii komentarzy. Implementuj odpowiednie style CSS/Tailwind dla wizualnego oznaczenia poziomów zagnieżdżenia. Dodaj lazy loading dla głębokich wątków.",
            "status": "pending",
            "testStrategy": "Sprawdź czy komentarze wyświetlają się w hierarchii, style wizualne są poprawne, lazy loading działa",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja komponentu AddCommentForm z walidacją",
            "description": "Stworzenie formularza dodawania komentarzy z walidacją i obsługą błędów",
            "dependencies": [],
            "details": "Stwórz AddCommentForm.tsx z polami: content, parentId (dla replies). Dodaj walidację react-hook-form: required content, max length. Implementuj obsługę błędów API, loading states. Dodaj rich text editor lub prosty textarea z preview.",
            "status": "pending",
            "testStrategy": "Sprawdź czy walidacja działa, błędy są wyświetlane, loading states działają poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie komponentu CommentItem z reply functionality",
            "description": "Implementacja pojedynczego komentarza z możliwością odpowiadania i podstawowymi akcjami",
            "dependencies": [
              1,
              2
            ],
            "details": "Stwórz CommentItem.tsx wyświetlający autor, content, timestamp. Dodaj przycisk Reply który pokazuje AddCommentForm inline. Implementuj toggle reply form, obsługę nested replies. Dodaj akcje edit/delete dla własnych komentarzy.",
            "status": "pending",
            "testStrategy": "Sprawdź czy reply form się pojawia, nested replies działają, edit/delete dla własnych komentarzy",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integracja Socket.io dla real-time updates",
            "description": "Implementacja real-time komunikacji dla natychmiastowych aktualizacji komentarzy",
            "dependencies": [
              1,
              3
            ],
            "details": "Skonfiguruj Socket.io client w CommentSection. Nasłuchuj eventów: new_comment, comment_updated, comment_deleted. Implementuj automatic refresh komponentu przy nowych komentarzach. Dodaj notifications dla nowych replies do user komentarzy.",
            "status": "pending",
            "testStrategy": "Sprawdź czy nowe komentarze pojawiają się real-time, updates działają automatycznie",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja comment moderation controls",
            "description": "Dodanie kontroli moderacyjnych dla administratorów i moderatorów",
            "dependencies": [
              3
            ],
            "details": "Dodaj moderation przyciski w CommentItem: approve, reject, ban user (tylko admin/moderator). Implementuj ModerationPanel z pending comments queue. Dodaj bulk actions dla moderacji. Implementuj comment reporting system.",
            "status": "pending",
            "testStrategy": "Sprawdź czy moderation controls są widoczne dla admin/moderator, bulk actions działają",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementacja comment threading i pagination",
            "description": "Dodanie systemu wątków komentarzy i paginacji dla dużej ilości komentarzy",
            "dependencies": [
              1,
              4
            ],
            "details": "Implementuj infinite scrolling lub pagination dla głównych komentarzy. Dodaj 'Load more replies' dla zagnieżdżonych komentarzy. Implementuj comment threading z collapse/expand functionality. Dodaj sorting options: newest, oldest, most liked.",
            "status": "pending",
            "testStrategy": "Sprawdź czy pagination działa, threading collapse/expand funkcjonuje, sorting opcje działają",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Dodanie comment voting/likes system",
            "description": "Implementacja systemu głosowania i polubień komentarzy (opcjonalna funkcjonalność)",
            "dependencies": [
              3
            ],
            "details": "Dodaj Like/Dislike buttons w CommentItem. Implementuj vote counter, prevent double voting. Dodaj hover effects, vote animations. Integruj z backend API dla vote persistence. Dodaj sorting po popularności.",
            "status": "pending",
            "testStrategy": "Sprawdź czy voting działa, double voting jest blokowane, counting jest poprawny",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implementacja comment editing i deletion",
            "description": "Dodanie funkcjonalności edycji i usuwania komentarzy przez użytkowników",
            "dependencies": [
              3
            ],
            "details": "Dodaj Edit button w CommentItem (tylko dla autor komentarza). Implementuj inline editing z save/cancel. Dodaj Delete button z confirmation modal. Implementuj edit history tracking. Dodaj 'edited' indicator przy zmodyfikowanych komentarzach.",
            "status": "pending",
            "testStrategy": "Sprawdź czy editing działa inline, delete confirmation pojawia się, edit history jest śledzona",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Stworzenie comment notifications UI",
            "description": "Implementacja interfejsu powiadomień o nowych komentarzach i odpowiedziach",
            "dependencies": [
              4
            ],
            "details": "Stwórz NotificationBell component z counter nowych komentarzy. Implementuj NotificationPanel z listą replies do user komentarzy. Dodaj mark as read functionality. Integruj z real-time socket events dla instant notifications.",
            "status": "pending",
            "testStrategy": "Sprawdź czy notifications pojawiają się real-time, mark as read działa, counter jest poprawny",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Integration testing całego systemu komentarzy",
            "description": "Kompleksowe testowanie wszystkich funkcjonalności systemu komentarzy",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Napisz integration testy: dodawanie komentarzy, nested replies, real-time updates, moderation workflow. Testuj cross-browser compatibility, mobile responsiveness. Przeprowadź performance testing z dużą ilością komentarzy. Testuj edge cases i error handling.",
            "status": "pending",
            "testStrategy": "Sprawdź czy cały workflow komentarzy działa end-to-end, performance jest acceptable, mobile działa",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Rozłóż na subtaski: 1) Komponent CommentList z nested display, 2) Komponent AddCommentForm z validation, 3) Komponent CommentItem z reply functionality, 4) Real-time updates z Socket.io, 5) Comment moderation controls dla admin, 6) Comment threading i pagination, 7) Comment voting/likes (opcjonalnie), 8) Comment editing i deletion, 9) Comment notifications UI, 10) Integration testing całego systemu komentarzy."
      },
      {
        "id": "31",
        "title": "Implementacja rating widget i search",
        "description": "System oceniania i zaawansowane wyszukiwanie",
        "details": "Stwórz RatingWidget component (1-5 stars), SearchBar z autocomplete, SearchResults page z faceted search. Integruj z MeiliSearch API. Dodaj filtering options, sorting, search history dla zalogowanych użytkowników.",
        "testStrategy": "Sprawdź czy rating widget zapisuje oceny, search autocomplete działa, faceted search zwraca odpowiednie wyniki, search history zapisuje się",
        "priority": "medium",
        "dependencies": [
          "30"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implementacja StarRating widget komponentu",
            "description": "Stworzenie interaktywnego komponentu do oceniania treści w skali 1-5 gwiazdek z animacjami hover i kliknięć",
            "dependencies": [],
            "details": "Stwórz React komponent StarRating z state management dla aktualnej oceny, hover effects, animacje przy kliknięciu, readonly mode dla wyświetlania średniej oceny. Użyj Tailwind CSS do stylowania ikon gwiazdek. Implementuj onRatingChange callback dla zapisywania ocen w bazie danych.",
            "status": "pending",
            "testStrategy": "Sprawdź czy gwiazdki reagują na hover, kliknięcie zapisuje ocenę, readonly mode wyświetla średnią, animacje działają płynnie",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja SearchBar z autocomplete",
            "description": "Stworzenie paska wyszukiwania z funkcjonalnością autocomplete i debounced search",
            "dependencies": [],
            "details": "Stwórz SearchBar komponent z input field, dropdown z sugestiami, debounced search (300ms), keyboard navigation (strzałki, Enter, Escape). Implementuj useDebounce hook, integracja z search API dla autocomplete. Dodaj loading state i error handling.",
            "status": "pending",
            "testStrategy": "Sprawdź czy autocomplete wyświetla sugestie po wpisaniu 3 znaków, debounce działa, navigation klawiaturą działa, loading state jest widoczny",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implementacja SearchResults page z paginacją",
            "description": "Stworzenie strony wyników wyszukiwania z paginacją i wyświetlaniem znalezionych treści",
            "dependencies": [
              2
            ],
            "details": "Stwórz SearchResults komponent wyświetlający wyniki w grid/list layout, implementuj paginację z infinite scroll lub page numbers. Dodaj search metadata (liczba wyników, czas wyszukiwania). Użyj SWR do cache'owania wyników.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wyniki wyświetlają się poprawnie, paginacja ładuje kolejne strony, metadata jest aktualna, cache działa",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implementacja faceted search filters",
            "description": "Stworzenie systemu filtrów dla wyszukiwania po kategoriach, tagach, dacie i innych kryteriach",
            "dependencies": [
              3
            ],
            "details": "Stwórz FilterPanel komponent z checkboxami dla kategorii, tagów, date range picker, sortowanie. Implementuj multi-select filters, clear all filters, filter badges. Użyj URLSearchParams do persistencji filtrów w URL.",
            "status": "pending",
            "testStrategy": "Sprawdź czy filtry ograniczają wyniki, multi-select działa, clear filters resetuje wszystko, URL params są aktualizowane",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja search history management",
            "description": "System zarządzania historią wyszukiwań dla zalogowanych użytkowników",
            "dependencies": [],
            "details": "Stwórz SearchHistory komponent wyświetlający ostatnie wyszukiwania, implementuj zapisywanie historii w localStorage i backend API. Dodaj możliwość usuwania pojedynczych wpisów i czyszczenia całej historii. Ograniczenie do 20 ostatnich wyszukiwań.",
            "status": "pending",
            "testStrategy": "Sprawdź czy historia zapisuje się lokalnie i w bazie, można usuwać wpisy, limit 20 wpisów jest przestrzegany",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implementacja advanced search options UI",
            "description": "Interfejs dla zaawansowanych opcji wyszukiwania z wieloma kryteriami",
            "dependencies": [
              4
            ],
            "details": "Stwórz AdvancedSearch modal/page z polami: exact phrase, any/all words, author filter, date range, content type selection. Implementuj query builder generujący MeiliSearch query syntax. Dodaj save search functionality.",
            "status": "pending",
            "testStrategy": "Sprawdź czy zaawansowane opcje generują właściwe query, można zapisywać wyszukiwania, modal otwiera/zamyka się poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementacja search suggestions i typo correction",
            "description": "System sugestii wyszukiwania i korekcji błędów ortograficznych",
            "dependencies": [
              2
            ],
            "details": "Implementuj typo tolerance w MeiliSearch, suggestion engine dla popularnych fraz, did-you-mean functionality. Stwórz SearchSuggestions komponent wyświetlający alternatywne frazy. Dodaj trending searches widget.",
            "status": "pending",
            "testStrategy": "Sprawdź czy błędy ortograficzne są korygowane, sugestie wyświetlają się, trending searches są aktualne",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Integracja z MeiliSearch API i optymalizacja performance",
            "description": "Pełna integracja z MeiliSearch backend oraz optymalizacja wydajności wyszukiwania",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Skonfiguruj MeiliSearch indeksy dla wszystkich typów treści, implementuj search API endpoints w NestJS. Dodaj caching strategię, rate limiting dla search API, analytics tracking. Optymalizuj query performance i relevance scoring.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie typy treści są wyszukiwalne, performance jest zadowalająca (<200ms), caching działa, analytics zapisują się",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Rozłóż na subtaski: 1) Komponent StarRating widget z interakcją, 2) SearchBar z autocomplete funkcjonalnością, 3) SearchResults page z pagination, 4) Faceted search filters (kategorie, tagi, data), 5) Search history management, 6) Advanced search options UI, 7) Search suggestions i typo correction, 8) Integration z MeiliSearch API i performance optimization."
      },
      {
        "id": "32",
        "title": "Implementacja admin panel frontend",
        "description": "Pełnofunkcyjny panel administracyjny z dashboard i CRUD",
        "details": "Stwórz /dashboard layout z sidebar navigation. Implementuj dashboard overview z charts (Tremor/Recharts), CRUD interfaces dla wszystkich content types. Dodaj Rich Text Editor (Tiptap), TanStack Table dla list views, user management interface.",
        "testStrategy": "Sprawdź czy admin dashboard ładuje się dla admin users, wszystkie CRUD operacje działają, rich text editor działa, charts wyświetlają dane",
        "priority": "high",
        "dependencies": [
          "31"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie admin layout z sidebar navigation",
            "description": "Implementacja podstawowego layoutu dla panelu administracyjnego z bocznym menu nawigacyjnym",
            "dependencies": [],
            "details": "Stwórz /dashboard/layout.tsx z responsive sidebar navigation. Implementuj navigation items: Dashboard, Articles, Blog, Wiki, Gallery, Stories, Authors, Users, Settings. Dodaj logo, user dropdown, logout functionality. Użyj Tailwind dla styling, dodaj mobile hamburger menu.",
            "status": "pending",
            "testStrategy": "Sprawdź czy sidebar navigation działa na desktop i mobile, wszystkie linki prowadzą do właściwych stron, user dropdown wyświetla poprawne informacje",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Dashboard overview z charts i statystykami",
            "description": "Implementacja głównego dashboard z wykresami i statystykami systemu",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/page.tsx z overview cards (total users, articles, blog posts, etc.). Implementuj charts używając Tremor lub Recharts - line chart dla user registrations, bar chart dla content creation. Dodaj API endpoint GET /admin/dashboard dla statystyk.",
            "status": "pending",
            "testStrategy": "Sprawdź czy dashboard ładuje się dla admin users, charts wyświetlają poprawne dane, overview cards pokazują aktualne statystyki",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Articles CRUD interface",
            "description": "Pełny interfejs CRUD dla zarządzania artykułami w panelu admin",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/articles/page.tsx z listą artykułów używając TanStack Table. Implementuj /dashboard/articles/new i /dashboard/articles/[id]/edit z formularzami. Dodaj Rich Text Editor (Tiptap) dla content. Implementuj search, filtering po kategoriach/tagach.",
            "status": "pending",
            "testStrategy": "Sprawdź czy można tworzyć, edytować, usuwać artykuły, rich text editor działa poprawnie, filtering i search działają",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Blog CRUD interface",
            "description": "Interfejs CRUD dla zarządzania postami blogowymi",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/blog/ z podobną strukturą do Articles. Implementuj listing z TanStack Table, forms dla tworzenia/edycji z Tiptap editor. Dodaj preview functionality, scheduling options dla publikacji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy blog posts można zarządzać przez admin panel, preview działa, scheduling publikacji funkcjonuje",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Wiki CRUD interface z hierarchical tree editor",
            "description": "Zaawansowany interfejs dla zarządzania stronami Wiki z hierarchiczną strukturą",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/wiki/ z tree view dla hierarchii stron. Implementuj drag-and-drop dla reorganizacji struktury. Dodaj parent-child relationship management, breadcrumbs navigation w editorze.",
            "status": "pending",
            "testStrategy": "Sprawdź czy hierarchia Wiki jest poprawnie wyświetlana, drag-and-drop działa, parent-child relationships są zachowane",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Gallery management interface",
            "description": "Interfejs do zarządzania mediami w galerii z upload functionality",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/gallery/ z grid view dla mediów. Implementuj drag-and-drop file upload, image preview, bulk operations. Dodaj metadata editing, category/tag assignment, file size optimization.",
            "status": "pending",
            "testStrategy": "Sprawdź czy upload plików działa, preview obrazów wyświetla się, bulk operations działają, metadata można edytować",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Stories CRUD interface",
            "description": "Interfejs CRUD dla zarządzania opowiadaniami z supportem dla serii",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/stories/ z listing i forms. Implementuj series management - tworzenie, edycja, przypisywanie stories do serii. Dodaj ordering w ramach serii, chapters management.",
            "status": "pending",
            "testStrategy": "Sprawdź czy stories można grupować w serie, ordering w serii działa, chapters management funkcjonuje poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Authors management interface",
            "description": "Interfejs do zarządzania profilami autorów",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/authors/ z CRUD dla author profiles. Implementuj image upload dla avatar, bio editor z Tiptap, social links management. Dodaj content assignment - linking content to authors.",
            "status": "pending",
            "testStrategy": "Sprawdź czy profile autorów można tworzyć i edytować, image upload działa, content assignment funkcjonuje",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "User management z role changes",
            "description": "Pełny interfejs zarządzania użytkownikami z możliwością zmiany ról",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/users/ z user listing używając TanStack Table. Implementuj role management (user, moderator, admin), user status changes (active, suspended). Dodaj user activity logs, bulk operations.",
            "status": "pending",
            "testStrategy": "Sprawdź czy można zmieniać role użytkowników, user status changes działają, activity logs są wyświetlane",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Rich Text Editor (Tiptap) integration",
            "description": "Konfiguracja i integracja Tiptap editor dla wszystkich content types",
            "dependencies": [],
            "details": "Zainstaluj @tiptap/react i extensions. Stwórz reusable RichTextEditor component z toolbar (bold, italic, lists, links, images). Implementuj image upload handling, HTML sanitization, content validation.",
            "status": "pending",
            "testStrategy": "Sprawdź czy editor wyświetla się poprawnie, wszystkie toolbar options działają, image upload funkcjonuje, HTML jest sanitized",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "TanStack Table dla wszystkich list views",
            "description": "Implementacja zaawansowanych tabel z sorting, filtering i paginacją",
            "dependencies": [],
            "details": "Zainstaluj @tanstack/react-table. Stwórz reusable DataTable component z sorting, filtering, pagination. Implementuj column visibility, search functionality, bulk actions selection.",
            "status": "pending",
            "testStrategy": "Sprawdź czy tabele obsługują sorting, filtering działa poprawnie, pagination wyświetla właściwą liczbę rekordów, bulk actions działają",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Settings management interface",
            "description": "Panel ustawień systemu dla administratorów",
            "dependencies": [
              1
            ],
            "details": "Stwórz /dashboard/settings/ z sections: General Settings, Site Configuration, Email Settings, SEO Settings. Implementuj forms z validation, settings persistence w database, backup/restore functionality.",
            "status": "pending",
            "testStrategy": "Sprawdź czy ustawienia można zapisywać i wczytywać, validation działa, backup/restore funkcjonuje poprawnie",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 12,
        "expansionPrompt": "Rozłóż na subtaski: 1) Admin layout z sidebar navigation, 2) Dashboard overview z charts i statistics, 3) Articles CRUD interface, 4) Blog CRUD interface, 5) Wiki CRUD interface z tree editor, 6) Gallery management interface, 7) Stories CRUD interface, 8) Authors management, 9) User management z role changes, 10) Rich Text Editor (Tiptap) integration, 11) TanStack Table dla wszystkich list views, 12) Settings management interface."
      },
      {
        "id": "33",
        "title": "Implementacja real-time notifications frontend",
        "description": "Notification center z live updates i preferences",
        "details": "Stwórz NotificationCenter component z dropdown, badge counter, mark as read/unread. Integruj Socket.io client, notification toast system. Dodaj notification preferences page, browser push notifications support.",
        "testStrategy": "Sprawdź czy notifications wyświetlają się real-time, badge counter aktualizuje się, toast notifications działają, preferences zapisują się",
        "priority": "medium",
        "dependencies": [
          "32"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Stworzenie NotificationCenter dropdown component",
            "description": "Implementacja głównego komponentu NotificationCenter z dropdown menu i listą powiadomień",
            "dependencies": [],
            "details": "Stwórz NotificationCenter komponent w Next.js z dropdown menu używając Tailwind CSS. Implementuj listę powiadomień z avatar użytkownika, tytułem, treścią i timestampem. Dodaj state management dla otwarcia/zamknięcia dropdown. Zaimplementuj lazy loading dla starszych powiadomień.",
            "status": "pending",
            "testStrategy": "Sprawdź czy dropdown otwiera się/zamyka poprawnie, lista powiadomień wyświetla się, lazy loading działa przy scrollowaniu",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implementacja notification badge counter z real-time updates",
            "description": "Stworzenie badge counter pokazującego liczbę nieprzeczytanych powiadomień z aktualizacjami w czasie rzeczywistym",
            "dependencies": [
              1
            ],
            "details": "Dodaj badge counter do NotificationCenter component. Implementuj licznik nieprzeczytanych powiadomień z real-time updates przez Socket.io. Zastosuj czerwony badge z białym tekstem, ukryj gdy brak powiadomień. Dodaj animacje dla nowych powiadomień.",
            "status": "pending",
            "testStrategy": "Sprawdź czy badge pokazuje poprawną liczbę, aktualizuje się w real-time, animacje działają przy nowych powiadomieniach",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Stworzenie toast notification system",
            "description": "Implementacja systemu toast notifications dla powiadomień w czasie rzeczywistym",
            "dependencies": [],
            "details": "Stwórz ToastNotification komponent używając biblioteki react-hot-toast lub react-toastify. Implementuj różne typy toastów (success, info, warning, error). Dodaj customowe styling zgodny z design system. Skonfiguruj auto-dismiss i pozycjonowanie toastów.",
            "status": "pending",
            "testStrategy": "Sprawdź czy toasty wyświetlają się w odpowiednim czasie, różne typy mają odpowiednie style, auto-dismiss działa",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integracja Socket.io client i event handling",
            "description": "Konfiguracja Socket.io client do odbierania powiadomień w czasie rzeczywistym",
            "dependencies": [
              2,
              3
            ],
            "details": "Zainstaluj socket.io-client, stwórz socket service/hook. Implementuj połączenie z backend Socket.io server, obsługę eventów 'newNotification', 'notificationRead'. Dodaj reconnection logic i error handling. Integruj z NotificationCenter i toast system.",
            "status": "pending",
            "testStrategy": "Sprawdź czy socket łączy się z backend, eventy są odbierane, reconnection działa przy utracie połączenia",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Stworzenie notification preferences page",
            "description": "Implementacja strony ustawień powiadomień gdzie użytkownicy mogą konfigurować preferencje",
            "dependencies": [],
            "details": "Stwórz NotificationPreferences page w /dashboard/settings/notifications. Implementuj formularz z checkboxami dla różnych typów powiadomień (email, push, in-app). Dodaj integrację z backend API, zapisywanie ustawień do bazy danych. Użyj react-hook-form do walidacji.",
            "status": "pending",
            "testStrategy": "Sprawdź czy preferencje zapisują się w bazie, formularz waliduje poprawnie, ustawienia ładują się przy odwiedzeniu strony",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Konfiguracja browser push notifications",
            "description": "Implementacja wsparcia dla natywnych powiadomień przeglądarki",
            "dependencies": [
              5
            ],
            "details": "Implementuj Web Push API używając service worker. Stwórz funkcje do requestowania permissions, subskrypcji push notifications. Dodaj integrację z backend dla wysyłania push notifications. Implementuj handling kliknięć w powiadomienia przeglądarki.",
            "status": "pending",
            "testStrategy": "Sprawdź czy browser permissions działają, push notifications są odbierane, kliknięcia w powiadomienia przekierowują poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implementacja notification persistence i mark as read functionality",
            "description": "Dodanie funkcjonalności oznaczania powiadomień jako przeczytane i ich trwałego przechowywania",
            "dependencies": [
              1,
              4
            ],
            "details": "Implementuj funkcje markAsRead, markAllAsRead w NotificationCenter. Dodaj persystencję stanu powiadomień w localStorage i synchronizację z backend. Stwórz visual indicators dla przeczytanych/nieprzeczytanych powiadomień. Implementuj bulk actions do zarządzania powiadomieniami.",
            "status": "pending",
            "testStrategy": "Sprawdź czy oznaczanie jako przeczytane działa, stan synchronizuje się z backend, visual indicators pokazują poprawny status",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Rozłóż na subtaski: 1) NotificationCenter dropdown component, 2) Notification badge counter z real-time updates, 3) Toast notification system, 4) Socket.io client integration i event handling, 5) Notification preferences page, 6) Browser push notifications setup, 7) Notification persistence i mark as read functionality."
      },
      {
        "id": "34",
        "title": "Testowanie i optymalizacja performance",
        "description": "Unit testy, E2E testy i optymalizacja wydajności",
        "details": "Napisz unit testy dla critical backend services, integration testy dla API endpoints, E2E testy z Playwright dla user workflows. Optymalizuj bundle size, implementuj code splitting, dodaj error boundary components. Osiągnij Lighthouse score > 90.",
        "testStrategy": "Sprawdź czy wszystkie testy przechodzą (npm test), coverage > 70%, Lighthouse score > 90, bundle size < 200KB main chunk",
        "priority": "medium",
        "dependencies": [
          "33"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Unit testy dla critical backend services",
            "description": "Napisz unit testy dla kluczowych serwisów backendu używając Jest framework",
            "dependencies": [],
            "details": "Stwórz unit testy dla AuthService, UserService, ArticleService, BlogService, WikiService, GalleryService, CommentService, RatingService. Użyj Jest i mocking bibliotek. Pokryj edge cases, error handling, business logic validation. Osiągnij coverage > 80% dla critical services.",
            "status": "pending",
            "testStrategy": "Uruchom npm test w backend/, sprawdź coverage report, wszystkie testy muszą przechodzić",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "API integration testy z Supertest",
            "description": "Implementuj integration testy dla wszystkich API endpoints używając Supertest",
            "dependencies": [
              1
            ],
            "details": "Stwórz integration testy dla wszystkich REST endpoints: auth, articles, blog, wiki, gallery, comments, ratings. Użyj Supertest do testowania HTTP requests/responses. Testuj authentication, authorization, CRUD operations, error responses, data validation.",
            "status": "pending",
            "testStrategy": "Uruchom npm run test:e2e w backend/, wszystkie API endpoints muszą odpowiadać poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Frontend component testy z Testing Library",
            "description": "Napisz testy komponentów React używając React Testing Library i Jest",
            "dependencies": [],
            "details": "Stwórz testy dla key components: Navigation, Footer, ArticleCard, BlogCard, CommentSection, RatingWidget, AdminPanel components. Testuj user interactions, props rendering, state changes, form submissions. Użyj @testing-library/react i @testing-library/user-event.",
            "status": "pending",
            "testStrategy": "Uruchom npm test w frontend/, sprawdź coverage report dla komponentów",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "E2E testy z Playwright dla user workflows",
            "description": "Implementuj end-to-end testy dla kluczowych user journeys używając Playwright",
            "dependencies": [
              2,
              3
            ],
            "details": "Stwórz Playwright testy dla: user registration/login, article creation/editing, blog posting, wiki page creation, gallery upload, commenting, rating. Testuj full user workflows w różnych browserach (Chrome, Firefox, Safari). Dodaj fixtures i page objects pattern.",
            "status": "pending",
            "testStrategy": "Uruchom npx playwright test, wszystkie user flows muszą działać w różnych browserach",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Performance testing z k6 load tests",
            "description": "Implementuj load testing używając k6 dla sprawdzenia wydajności API",
            "dependencies": [
              2
            ],
            "details": "Stwórz k6 scripts dla load testing API endpoints. Testuj scenarios: normal load (10 users), stress load (100 users), spike test. Monitoruj response times, throughput, error rates. Ustaw performance thresholds: avg response < 500ms, 95th percentile < 1s, error rate < 1%.",
            "status": "pending",
            "testStrategy": "Uruchom k6 testy, sprawdź czy API spełnia performance requirements pod load",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Bundle size optimization i code splitting",
            "description": "Optymalizuj rozmiar bundle i implementuj code splitting w Next.js aplikacji",
            "dependencies": [],
            "details": "Zaimplementuj dynamic imports dla heavy components, route-based code splitting, vendor chunks separation. Użyj webpack-bundle-analyzer do analizy bundle size. Optymalizuj imports (tree shaking), usuń unused dependencies. Cel: main chunk < 200KB, vendor chunk < 500KB.",
            "status": "pending",
            "testStrategy": "Uruchom npm run build, sprawdź bundle analyzer report, main chunk musi być < 200KB",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Image optimization i lazy loading",
            "description": "Implementuj optymalizację obrazów i lazy loading dla lepszej wydajności",
            "dependencies": [],
            "details": "Użyj Next.js Image component z automatic optimization. Implementuj lazy loading dla gallery images, responsive images z różnymi sizes. Dodaj WebP format support, blur placeholder podczas ładowania. Optymalizuj JPEG/PNG compression settings.",
            "status": "pending",
            "testStrategy": "Sprawdź w dev tools Network tab czy images są lazy loaded i optimized",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Database query optimization i indexing",
            "description": "Optymalizuj zapytania do bazy danych i dodaj odpowiednie indeksy",
            "dependencies": [],
            "details": "Przeanalizuj slow queries w PostgreSQL logs. Dodaj database indexes dla często używanych pól: user_id, created_at, title, category_id, tag relations. Optymalizuj N+1 queries używając Prisma include/select. Dodaj connection pooling configuration.",
            "status": "pending",
            "testStrategy": "Sprawdź query performance w database logs, slow queries < 100ms",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Lighthouse audit i Core Web Vitals improvement",
            "description": "Przeprowadź Lighthouse audit i popraw Core Web Vitals metrics",
            "dependencies": [
              6,
              7
            ],
            "details": "Uruchom Lighthouse audit dla wszystkich key pages. Popraw First Contentful Paint, Largest Contentful Paint, Cumulative Layout Shift, First Input Delay. Zoptymalizuj critical CSS, usuń render-blocking resources, dodaj preload dla important assets. Cel: Lighthouse score > 90.",
            "status": "pending",
            "testStrategy": "Uruchom Lighthouse audit, sprawdź czy wszystkie pages mają score > 90",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Error boundary components i error handling",
            "description": "Implementuj comprehensive error handling i error boundary components",
            "dependencies": [],
            "details": "Stwórz ErrorBoundary components dla różnych sekcji aplikacji. Implementuj error logging system (Sentry lub własny). Dodaj user-friendly error pages, fallback UI components, retry mechanisms. Obsługuj network errors, API failures, authentication errors.",
            "status": "pending",
            "testStrategy": "Testuj error scenarios, sprawdź czy error boundaries catch errors i pokazują fallback UI",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Rozłóż na subtaski: 1) Backend unit tests dla critical services, 2) API integration tests z Supertest, 3) Frontend component tests z Testing Library, 4) E2E tests z Playwright dla user workflows, 5) Performance testing z k6 load tests, 6) Bundle size optimization i code splitting, 7) Image optimization i lazy loading, 8) Database query optimization i indexing, 9) Lighthouse audit i Core Web Vitals improvement, 10) Error boundary components i error handling."
      },
      {
        "id": "35",
        "title": "Deployment i dokumentacja",
        "description": "Production deployment, monitoring i finalna dokumentacja",
        "details": "Skonfiguruj production Docker Compose, deploy na VPS (Hetzner/Contabo), skonfiguruj domain i SSL (Let's Encrypt), Cloudflare CDN. Dodaj Prometheus/Grafana monitoring, backup strategy. Napisz kompletny README.md, API docs, deployment guide.",
        "testStrategy": "Sprawdź czy aplikacja działa na produkcji, SSL certificate jest valid, monitoring dashboards działają, backup system skonfigurowany",
        "priority": "high",
        "dependencies": [
          "34"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Konfiguracja production Docker Compose",
            "description": "Przygotowanie zoptymalizowanej konfiguracji Docker Compose dla środowiska produkcyjnego",
            "dependencies": [],
            "details": "Stwórz docker-compose.prod.yml z optimized images (multi-stage builds), environment variables, resource limits, restart policies. Skonfiguruj separate networks dla frontend/backend/database. Dodaj Redis cache, reverse proxy (nginx). Użyj secrets management dla sensitive data.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie kontenery startują poprawnie, aplikacja jest dostępna przez reverse proxy, environment variables są poprawnie załadowane",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Setup VPS i konfiguracja domeny",
            "description": "Przygotowanie serwera VPS i skonfigurowanie domeny dla aplikacji",
            "dependencies": [
              1
            ],
            "details": "Wynajmij VPS (Hetzner/Contabo), zainstaluj Docker i Docker Compose. Skonfiguruj firewall (UFW), SSH keys, podstawowe security hardening. Zarejestruj domenę, skonfiguruj DNS records (A, AAAA, CNAME). Setup non-root user z sudo privileges.",
            "status": "pending",
            "testStrategy": "Sprawdź czy SSH connection działa, domena resolve się na IP serwera, podstawowe security checks przechodzą",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Konfiguracja SSL certificate z Let's Encrypt",
            "description": "Implementacja automatycznego SSL certificate management",
            "dependencies": [
              2
            ],
            "details": "Zainstaluj Certbot, skonfiguruj automatic SSL certificate generation i renewal. Dodaj nginx reverse proxy z SSL termination. Skonfiguruj auto-redirect HTTP->HTTPS, HSTS headers, secure SSL configuration. Setup cron job dla automatic renewal.",
            "status": "pending",
            "testStrategy": "Sprawdź czy SSL certificate jest valid, auto-renewal działa, security headers są obecne, SSL Labs rating A+",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Konfiguracja Cloudflare CDN",
            "description": "Setup Cloudflare jako CDN i dodatkowa warstwa security",
            "dependencies": [
              3
            ],
            "details": "Dodaj domenę do Cloudflare, skonfiguruj DNS proxy, enable CDN caching rules. Setup page rules dla static assets, enable security features (DDoS protection, WAF). Skonfiguruj cache purging, optimize images, enable Brotli compression.",
            "status": "pending",
            "testStrategy": "Sprawdź czy static assets są cache'owane przez Cloudflare, page load speed poprawił się, security features są aktywne",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implementacja database backup strategy",
            "description": "Skonfigurowanie automatycznego systemu backupów bazy danych",
            "dependencies": [
              2
            ],
            "details": "Stwórz automated backup script dla PostgreSQL (pg_dump). Skonfiguruj daily/weekly/monthly retention policy. Setup backup storage (S3/external storage). Dodaj backup verification, restore procedure documentation. Skonfiguruj cron jobs i monitoring backups.",
            "status": "pending",
            "testStrategy": "Sprawdź czy backupy są tworzone regularnie, restore process działa, backup files są przechowywane bezpiecznie",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Setup monitoringu Prometheus/Grafana",
            "description": "Implementacja kompleksowego systemu monitoringu aplikacji",
            "dependencies": [
              1
            ],
            "details": "Zainstaluj Prometheus do metrics collection, Grafana do visualization. Skonfiguruj metrics exports z aplikacji (Node.js metrics, custom business metrics). Stwórz dashboards dla system metrics, application performance, user activity. Setup alerting rules.",
            "status": "pending",
            "testStrategy": "Sprawdź czy metrics są zbierane, dashboards wyświetlają dane, alerting działa przy problemach",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Napisanie comprehensive README.md",
            "description": "Stworzenie kompletnej dokumentacji projektu w README.md",
            "dependencies": [],
            "details": "Napisz README.md z: project overview, architecture diagram, installation instructions, development setup, environment variables, API endpoints overview, deployment instructions, troubleshooting guide. Dodaj badges (build status, coverage), screenshots, feature list.",
            "status": "pending",
            "testStrategy": "Sprawdź czy README jest kompletny, instrukcje są clear i actionable, wszystkie sekcje są pokryte",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Finalizacja dokumentacji API",
            "description": "Stworzenie kompletnej dokumentacji wszystkich API endpoints",
            "dependencies": [],
            "details": "Wygeneruj Swagger/OpenAPI documentation dla wszystkich endpoints. Dodaj examples dla requests/responses, error codes, authentication flow. Stwórz Postman collection. Dodaj rate limiting information, versioning strategy. Host documentation online.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie endpoints są udokumentowane, examples działają, Postman collection importuje się poprawnie",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Stworzenie dokumentacji architektury",
            "description": "Dokumentacja high-level architektury systemu i design decisions",
            "dependencies": [],
            "details": "Stwórz architecture.md z: system overview diagram, database schema, technology stack rationale, security considerations, scalability plans, design patterns used. Dodaj deployment architecture, CI/CD pipeline diagram, monitoring strategy overview.",
            "status": "pending",
            "testStrategy": "Sprawdź czy dokumentacja architektury jest kompletna, diagramy są readable, design decisions są wyjaśnione",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Post-deployment verification i testing",
            "description": "Comprehensive testing aplikacji w środowisku produkcyjnym",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Przeprowadź end-to-end testing na production environment. Sprawdź wszystkie funkcjonalności, performance testing, security scanning. Zweryfikuj monitoring dashboards, backup system, SSL configuration. Wykonaj load testing, user acceptance testing.",
            "status": "pending",
            "testStrategy": "Sprawdź czy wszystkie features działają na produkcji, performance jest acceptable, security nie ma vulnerabilities, monitoring alertuje o problemach",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Rozłóż na subtaski: 1) Production Docker Compose configuration, 2) VPS setup i domain configuration, 3) SSL certificate setup z Let's Encrypt, 4) Cloudflare CDN configuration, 5) Database backup strategy implementation, 6) Monitoring setup (Prometheus/Grafana), 7) README.md z comprehensive instructions, 8) API documentation finalization, 9) Architecture documentation creation, 10) Post-deployment verification i testing."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-11-06T16:56:29.610Z",
      "taskCount": 35,
      "completedCount": 13,
      "tags": [
        "master"
      ]
    }
  }
}